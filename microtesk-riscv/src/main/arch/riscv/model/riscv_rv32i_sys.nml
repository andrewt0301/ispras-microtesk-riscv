/*
 * Copyright 2017-2018 ISP RAS (http://www.ispras.ru)
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */

#ifndef RISCV_RV32I_SYS_INCLUDED
#define RISCV_RV32I_SYS_INCLUDED

//==================================================================================================
// Control and status registers (CSRs)
//==================================================================================================

// 2 ** 12 (4096) registers
reg CSR[1 << 12, XWORD]

// Index of the currently accessed register
var csr_index[card(12)]

//==================================================================================================
// User Trap Setup

// User status register
mode USTATUS() = CSR[0x000]
  init = { csr_index = 0x000; }
  syntax = format("ustatus")
  image = format("%12s", csr_index)

// User interrupt-enable register
mode UIE() = CSR[0x004]
  init = { csr_index = 0x004; }
  syntax = format("uie")
  image = format("%12s", csr_index)

// User trap handler base address
mode UTVEC() = CSR[0x005]
  init = { csr_index = 0x005; }
  syntax = format("utvec")
  image = format("%12s", csr_index)

//==================================================================================================
// User Trap Handling

// Scratch register for user trap handlers
mode USCRATCH() = CSR[0x040]
  init = { csr_index = 0x040; }
  syntax = format("uscratch")
  image = format("%12s", csr_index)

// User exception program counter
mode UEPC() = CSR[0x041]
  init = { csr_index = 0x041; }
  syntax = format("uepc")
  image = format("%12s", csr_index)

// User trap cause
mode UCAUSE() = CSR[0x042]
  init = { csr_index = 0x042; }
  syntax = format("ucause")
  image = format("%12s", csr_index)

// User bad address or instruction
mode UTVAL() = CSR[0x043]
  init = { csr_index = 0x043; }
  syntax = format("utval")
  image = format("%12s", csr_index)

// User interrupt pending
mode UIP() = CSR[0x044]
  init = { csr_index = 0x044; }
  syntax = format("uip")
  image = format("%12s", csr_index)

//==================================================================================================
// User Floating-Point CSRs

// Floating-Point Accrued Exceptions
mode FFLAGS() = CSR[0x001]
  init = { csr_index = 0x001; }
  syntax = format("fflags")
  image = format("%12s", csr_index)

// Floating-Point Dynamic Rounding Mode
mode FRM() = CSR[0x002]
  init = { csr_index = 0x002; }
  syntax = format("frm")
  image = format("%12s", csr_index)

// Floating-Point Control and Status Register (frm + fflags)
mode FCSR() = CSR[0x003]
  init = { csr_index = 0x003; }
  syntax = format("fcsr")
  image = format("%12s", csr_index)

//==================================================================================================
// User Counter/Timers

// Cycle counter for RDCYCLE instruction
mode CYCLE() = CSR[0xC00]
  init = { csr_index = 0xC00; }
  syntax = format("cycle")
  image = format("%12s", csr_index)

// Timer for RDTIME instruction
mode TIME() = CSR[0xC01]
  init = { csr_index = 0xC01; }
  syntax = format("time")
  image = format("%12s", csr_index)

// Instructions-retired counter for RDINSTRET instruction
mode INSTRET() = CSR[0xC02]
  init = { csr_index = 0xC02; }
  syntax = format("instret")
  image = format("%12s", csr_index)

// Upper 32 bits of cycle, RV32I only
mode CYCLEH() = CSR[0xC80]
  init = { csr_index = 0xC80; }
  syntax = format("cycleh")
  image = format("%12s", csr_index)

// Upper 32 bits of time, RV32I only
mode TIMEH() = CSR[0xC81]
  init = { csr_index = 0xC81; }
  syntax = format("timeh")
  image = format("%12s", csr_index)

// Upper 32 bits of instret, RV32I only
mode INSTRETH() = CSR[0xC82]
  init = { csr_index = 0xC82; }
  syntax = format("instreth")
  image = format("%12s", csr_index)

//==================================================================================================
// Supervisor Trap Setup

// Supervisor status register
mode SSTATUS() = CSR[0x100]
  init = { csr_index = 0x100; }
  syntax = format("sstatus")
  image = format("%12s", csr_index)

// Supervisor exception delegation register
mode SEDELEG() = CSR[0x102]
  init = { csr_index = 0x102; }
  syntax = format("sedeleg")
  image = format("%12s", csr_index)

// Supervisor interrupt delegation register
mode SIDELEG() = CSR[0x103]
  init = { csr_index = 0x103; }
  syntax = format("sideleg")
  image = format("%12s", csr_index)

// Supervisor interrupt-enable register
mode SIE() = CSR[0x104]
  init = { csr_index = 0x104; }
  syntax = format("sie")
  image = format("%12s", csr_index)

// Supervisor trap handler base address
mode STVEC() = CSR[0x105]
  init = { csr_index = 0x105; }
  syntax = format("stvec")
  image = format("%12s", csr_index)

// Supervisor counter enable
mode SCOUNTEREN() = CSR[0x106]
  init = { csr_index = 0x106; }
  syntax = format("scounteren")
  image = format("%12s", csr_index)

//==================================================================================================
// Supervisor Trap Handling

// Scratch register for supervisor trap handlers
mode SSCRATCH() = CSR[0x140]
  init = { csr_index = 0x140; }
  syntax = format("sscratch")
  image = format("%12s", csr_index)

// Supervisor exception program counter
mode SEPC() = CSR[0x141]
  init = { csr_index = 0x141; }
  syntax = format("sepc")
  image = format("%12s", csr_index)

// Supervisor trap cause
mode SCAUSE() = CSR[0x142]
  init = { csr_index = 0x142; }
  syntax = format("scause")
  image = format("%12s", csr_index)

// Supervisor bad address or instruction
mode STVAL() = CSR[0x143]
  init = { csr_index = 0x143; }
  syntax = format("stval")
  image = format("%12s", csr_index)

// Supervisor interrupt pending
mode SIP() = CSR[0x144]
  init = { csr_index = 0x144; }
  syntax = format("sip")
  image = format("%12s", csr_index)

//==================================================================================================
// Supervisor Protection and Translation

// Supervisor address translation and protection
mode SATP() = CSR[0x180]
  init = { csr_index = 0x180; }
  syntax = format("satp")
  image = format("%12s", csr_index)

//==================================================================================================
// Machine Information Registers

// Vendor ID
mode MVENDORID() = CSR[0xF11]
  init = { csr_index = 0xF11; }
  syntax = format("mvendorid")
  image = format("%12s", csr_index)

// Architecture ID
mode MARCHID() = CSR[0xF12]
  init = { csr_index = 0xF12; }
  syntax = format("marchid")
  image = format("%12s", csr_index)

// Implementation ID
mode MIMPID() = CSR[0xF13]
  init = { csr_index = 0xF13; }
  syntax = format("mimpid")
  image = format("%12s", csr_index)

// Hardware thread ID
mode MHARTID() = CSR[0xF14]
  init = { csr_index = 0xF14; }
  syntax = format("mhartid")
  image = format("%12s", csr_index)

//==================================================================================================
// Machine Trap Setup

// Machine status register
mode MSTATUS() = CSR[0x300]
  init = { csr_index = 0x300; }
  syntax = format("mstatus")
  image = format("%12s", csr_index)

// ISA and extensions
mode MISA() = CSR[0x301]
  init = { csr_index = 0x301; }
  syntax = format("misa")
  image = format("%12s", csr_index)

// Machine exception delegation register
mode MEDELEG() = CSR[0x302]
  init = { csr_index = 0x302; }
  syntax = format("medeleg")
  image = format("%12s", csr_index)

// Machine interrupt delegation register
mode MIDELEG() = CSR[0x303]
  init = { csr_index = 0x303; }
  syntax = format("mideleg")
  image = format("%12s", csr_index)

// Machine interrupt-enable register
mode MIE() = CSR[0x304]
  init = { csr_index = 0x304; }
  syntax = format("mie")
  image = format("%12s", csr_index)

// Machine trap-handler base address
mode MTVEC() = CSR[0x305]
  init = { csr_index = 0x305; }
  syntax = format("mtvec")
  image = format("%12s", csr_index)

// Machine counter enable
mode MCOUNTEREN() = CSR[0x306]
  init = { csr_index = 0x306; }
  syntax = format("mcounteren")
  image = format("%12s", csr_index)

//==================================================================================================
// Machine Trap Handling

// Scratch register for machine trap handlers
mode MSCRATCH() = CSR[0x340]
  init = { csr_index = 0x340; }
  syntax = format("mscratch")
  image = format("%12s", csr_index)

// Machine exception program counter
mode MEPC() = CSR[0x341]
  init = { csr_index = 0x341; }
  syntax = format("mepc")
  image = format("%12s", csr_index)

// Machine trap cause
mode MCAUSE() = CSR[0x342]
  init = { csr_index = 0x342; }
  syntax = format("mcause")
  image = format("%12s", csr_index)

// Machine bad address or instruction
mode MTVAL() = CSR[0x343]
  init = { csr_index = 0x343; }
  syntax = format("mtval")
  image = format("%12s", csr_index)

// Machine interrupt pending
mode MIP() = CSR[0x344]
  init = { csr_index = 0x344; }
  syntax = format("mip")
  image = format("%12s", csr_index)

//==================================================================================================
// Machine Protection and Translation

// Physical memory protection configuration
mode PMPCFG0() = CSR[0x3A0]
  init = { csr_index = 0x3A0; }
  syntax = format("pmpcfg0")
  image = format("%12s", csr_index)

// Physical memory protection configuration, RV32 only
mode PMPCFG1() = CSR[0x3A1]
  init = { csr_index = 0x3A1; }
  syntax = format("pmpcfg1")
  image = format("%12s", csr_index)

// Physical memory protection configuration
mode PMPCFG2() = CSR[0x3A2]
  init = { csr_index = 0x3A2; }
  syntax = format("pmpcfg2")
  image = format("%12s", csr_index)

// Physical memory protection configuration, RV32 only
mode PMPCFG3() = CSR[0x3A3]
  init = { csr_index = 0x3A3; }
  syntax = format("pmpcfg3")
  image = format("%12s", csr_index)

// Physical memory protection address register
mode PMPADDR0() = CSR[0x3B0]
  init = { csr_index = 0x3B0; }
  syntax = format("pmpaddr0")
  image = format("%12s", csr_index)

// Physical memory protection address register
mode PMPADDR1() = CSR[0x3B1]
  init = { csr_index = 0x3B1; }
  syntax = format("pmpaddr1")
  image = format("%12s", csr_index)

// Physical memory protection address register
mode PMPADDR2() = CSR[0x3B2]
  init = { csr_index = 0x3B2; }
  syntax = format("pmpaddr2")
  image = format("%12s", csr_index)

// Physical memory protection address register
mode PMPADDR3() = CSR[0x3B3]
  init = { csr_index = 0x3B3; }
  syntax = format("pmpaddr3")
  image = format("%12s", csr_index)

// Physical memory protection address register
mode PMPADDR4() = CSR[0x3B4]
  init = { csr_index = 0x3B4; }
  syntax = format("pmpaddr4")
  image = format("%12s", csr_index)

// Physical memory protection address register
mode PMPADDR5() = CSR[0x3B5]
  init = { csr_index = 0x3B5; }
  syntax = format("pmpaddr5")
  image = format("%12s", csr_index)

// Physical memory protection address register
mode PMPADDR6() = CSR[0x3B6]
  init = { csr_index = 0x3B6; }
  syntax = format("pmpaddr6")
  image = format("%12s", csr_index)

// Physical memory protection address register
mode PMPADDR7() = CSR[0x3B7]
  init = { csr_index = 0x3B7; }
  syntax = format("pmpaddr7")
  image = format("%12s", csr_index)

// Physical memory protection address register
mode PMPADDR8() = CSR[0x3B8]
  init = { csr_index = 0x3B8; }
  syntax = format("pmpaddr8")
  image = format("%12s", csr_index)

// Physical memory protection address register
mode PMPADDR9() = CSR[0x3B9]
  init = { csr_index = 0x3B9; }
  syntax = format("pmpaddr9")
  image = format("%12s", csr_index)

// Physical memory protection address register
mode PMPADDR10() = CSR[0x3BA]
  init = { csr_index = 0x3BA; }
  syntax = format("pmpaddr10")
  image = format("%12s", csr_index)

// Physical memory protection address register
mode PMPADDR11() = CSR[0x3BB]
  init = { csr_index = 0x3BB; }
  syntax = format("pmpaddr11")
  image = format("%12s", csr_index)

// Physical memory protection address register
mode PMPADDR12() = CSR[0x3BC]
  init = { csr_index = 0x3BC; }
  syntax = format("pmpaddr12")
  image = format("%12s", csr_index)

// Physical memory protection address register
mode PMPADDR13() = CSR[0x3BD]
  init = { csr_index = 0x3BD; }
  syntax = format("pmpaddr13")
  image = format("%12s", csr_index)

// Physical memory protection address register
mode PMPADDR14() = CSR[0x3BE]
  init = { csr_index = 0x3BE; }
  syntax = format("pmpaddr14")
  image = format("%12s", csr_index)

// Physical memory protection address register
mode PMPADDR15() = CSR[0x3BF]
  init = { csr_index = 0x3BF; }
  syntax = format("pmpaddr15")
  image = format("%12s", csr_index)

//==================================================================================================
// Machine Counter/Timers

// Machine cycle counter
mode MCYCLE() = CSR[0xB00]
  init = { csr_index = 0xB00; }
  syntax = format("mcycle")
  image = format("%12s", csr_index)

// Machine instructions-retired counter
mode MINSTRET() = CSR[0xB02]
  init = { csr_index = 0xB02; }
  syntax = format("minstret")
  image = format("%12s", csr_index)

// Upper 32 bits of mcycle, RV32I only
mode MCYCLEH() = CSR[0xB80]
  init = { csr_index = 0xB80; }
  syntax = format("mcycleh")
  image = format("%12s", csr_index)

// Upper 32 bits of minstret, RV32I only
mode MINSTRETH() = CSR[0xB82]
  init = { csr_index = 0xB82; }
  syntax = format("minstreth")
  image = format("%12s", csr_index)

//==================================================================================================
// Debug/Trace Registers (shared with Debug Mode)

// Debug/Trace trigger register select
mode TSELECT() = CSR[0x7A0]
  init = { csr_index = 0x7A0; }
  syntax = format("tselect")
  image = format("%12s", csr_index)

// First Debug/Trace trigger data register
mode TDATA1() = CSR[0x7A1]
  init = { csr_index = 0x7A1; }
  syntax = format("tdata1")
  image = format("%12s", csr_index)

// Second Debug/Trace trigger data register
mode TDATA2() = CSR[0x7A2]
  init = { csr_index = 0x7A2; }
  syntax = format("tdata2")
  image = format("%12s", csr_index)

// Third Debug/Trace trigger data register
mode TDATA3() = CSR[0x7A3]
  init = { csr_index = 0x7A3; }
  syntax = format("tdata3")
  image = format("%12s", csr_index)

//==================================================================================================
// Debug Mode Registers

// Debug control and status register
mode DCSR() = CSR[0x7B0]
  init = { csr_index = 0x7B0; }
  syntax = format("dcsr")
  image = format("%12s", csr_index)

// Debug PC
mode DPC() = CSR[0x7B1]
  init = { csr_index = 0x7B1; }
  syntax = format("dpc")
  image = format("%12s", csr_index)

// Debug scratch register
mode DSCRATCH() = CSR[0x7B2]
  init = { csr_index = 0x7B2; }
  syntax = format("dscratch")
  image = format("%12s", csr_index)

//==================================================================================================
// Addressing mode group for CSR registers
//==================================================================================================

mode CSR_MODE =
// User Trap Setup
                USTATUS
              | UIE
              | UTVEC
// User Trap Handling
              | USCRATCH
              | UEPC
              | UCAUSE
              | UTVAL
              | UIP
// User Floating-Point CSRs
              | FFLAGS
              | FRM
              | FCSR
// User Counter/Timers
              | CYCLE
              | TIME
              | INSTRET
              | CYCLEH
              | TIMEH
              | INSTRETH
// Supervisor Trap Setup
              | SSTATUS
              | SEDELEG
              | SIDELEG
              | SIE
              | STVEC
              | SCOUNTEREN
// Supervisor Trap Handling
              | SSCRATCH
              | SEPC
              | SCAUSE
              | STVAL
              | SIP
// Supervisor Protection and Translation
              | SATP
// Machine Information Registers
              | MVENDORID
              | MARCHID
              | MIMPID
              | MHARTID
// Machine Trap Setup
              | MSTATUS
              | MISA
              | MEDELEG
              | MIDELEG
              | MIE
              | MTVEC
              | MCOUNTEREN
// Machine Trap Handling
              | MSCRATCH
              | MEPC
              | MCAUSE
              | MTVAL
              | MIP
// Machine Protection and Translation
              | PMPCFG0
              | PMPCFG1
              | PMPCFG2
              | PMPCFG3
              | PMPADDR0
              | PMPADDR1
              | PMPADDR2
              | PMPADDR3
              | PMPADDR4
              | PMPADDR5
              | PMPADDR6
              | PMPADDR7
              | PMPADDR8
              | PMPADDR9
              | PMPADDR10
              | PMPADDR11
              | PMPADDR12
              | PMPADDR13
              | PMPADDR14
              | PMPADDR15
// Machine Counter/Timers
              | MCYCLE
              | MINSTRET
              | MCYCLEH
              | MINSTRETH
// Debug/Trace Registers (shared with Debug Mode)
              | TSELECT
              | TDATA1
              | TDATA2
              | TDATA3
// Debug Mode Registers
              | DCSR
              | DPC
              | DSCRATCH

//==================================================================================================
// System instructions
//==================================================================================================

/*
   Instructions (number: 10):
     ECALL
     EBREAK
     FENCE
     FENCE.I
     MRET
     SRET
     URET
     WFI
     CSRRW
     CSRRS
     CSRRC
     CSRRWI
     CSRRSI
     CSRRCI
*/

/* The ECALL instruction is used to make a request to the supporting execution environment. */
op ecall()
  syntax = format("ecall")
  image  = format("%12s00000%3s00000%7s", "000000000000", "000", "1110011")
  action = {
    // TODO
  }

/* The EBREAK instruction is used by debuggers to cause control to be transferred back to
   a debugging environment. */
op ebreak()
  syntax = format("ebreak")
  image  = format("%12s00000%3s00000%7s", "000000000001", "000", "1110011")
  action = {
    // TODO
  }

op fence()//(pred: card(4), succ: card(4))
  // syntax = format("fence 0x%x, 0x%x", pred, succ) TODO:
  syntax = format("fence")
  image  = format("%4s%4s%4s00000%3s00000%7s", "0000", "0000", "0000", "000", "0001111")
  action = {
    // TODO
  }

op fencei()
  syntax = format("fence.i")
  image  = format("%12s00000%3s00000%7s", "000000000000", "001", "0001111")
  action = {
    // TODO
  }

/*
  Trap-Return Instructions

  Format: mret
          sret
          uret

  Instructions to return from trap are encoded under the PRIV minor opcode.
  To return after handling a trap, there are separate trap return instructions per privilege level:
  MRET, SRET, and URET. MRET is always provided, while SRET must be provided if supervisor
  mode is supported. URET is only provided if user-mode traps are supported. An x RET instruction
  can be executed in privilege mode x or higher, where executing a lower-privilege x RET instruction
  will pop the relevant lower-privilege interrupt enable and privilege mode stack. In addition to
  manipulating the privilege stack, xRET sets the pc to the value stored in the x epc register.
*/
internal op xret(pc: CSR_MODE)
  action = {
    // TODO: check privileges and pop the privilege stack.
    PC = pc;
  }

op mret()
  syntax = format("mret")
  image  = format("00110000001000000000000001110011")
  action = {
    xret(MEPC()).action;
  }

op sret()
  syntax = format("sret")
  image  = format("00010000001000000000000001110011")
  action = {
    xret(SEPC()).action;
  }

op uret()
  syntax = format("uret")
  image  = format("00000000001000000000000001110011")
  action = {
    xret(UEPC()).action;
  }

/*
  Wait for Interrupt

  Format: wfi

  The Wait for Interrupt instruction (WFI) provides a hint to the implementation that the current
  hart can be stalled until an interrupt might need servicing. Execution of the WFI instruction
  can also be used to inform the hardware platform that suitable interrupts should preferentially
  be routed to this hart. WFI is available in all of the supported S and M privilege modes, and
  optionally available to U-mode for implementations that support U-mode interrupts.
*/
op wfi()
  syntax = format("wfi")
  image  = format("00010000010100000000000001110011")
  action = {
    // TODO
  }

/* CSRRW (Atomic Read/Write CSR) */
op csrrw(rd: X, csr: CSR_MODE, rs1: X)
  syntax = format("csrrw %s, %s, %s", rd.syntax, csr.syntax, rs1.syntax)
  image  = format("%12s%5s001%5s1110011", csr.image, rs1.image, rd.image)
  action = {
    if rd.i != 0 then
      rd = zero_extend(XWORD, csr);
    endif;
    csr = rs1;
  }

/* CSRRS (Atomic Read and Set Bits in CSR) */
op csrrs(rd: X, csr: CSR_MODE, rs1: X)
  syntax = format("csrrs %s, %s, %s", rd.syntax, csr.syntax, rs1.syntax)
  image  = format("%12s%5s010%5s1110011", csr.image, rs1.image, rd.image)
  action = {
    if rs1.i != 0 then
      csr = csr | rs1;
    endif;
    rd = zero_extend(XWORD, csr);
  }

/* CSRRC (Atomic Read and Clear Bits in CSR) */
op csrrc(rd: X, csr: CSR_MODE, rs1: X)
  syntax = format("csrrc %s, %s, %s", rd.syntax, csr.syntax, rs1.syntax)
  image  = format("%12s%5s011%5s1110011", csr.image, rs1.image, rd.image)
  action = {
    if rs1.i != 0 then
      csr = csr & ~rs1;
    endif;
    rd = zero_extend(XWORD, csr);
  }

/* The CSRRWI, CSRRSI, and CSRRCI variants are similar to CSRRW, CSRRS, and CSRRC re-
  spectively, except they update the CSR using an XLEN-bit value obtained by zero-extending a 5-bit
  unsigned immediate (uimm[4:0]) */
op csrrwi(rd: X, csr: CSR_MODE, imm: card(5))
  syntax = format("csrrwi %s, %s, 0x%x", rd.syntax, csr.syntax, imm)
  image  = format("%12s%5s101%5s1110011", csr.image, imm, rd.image)
  action = {
    if rd.i != 0 then
      rd = zero_extend(XWORD, csr);
    endif;
    csr = zero_extend(XWORD, imm);
  }

op csrrsi(rd: X, csr: CSR_MODE, imm: card(5))
  syntax = format("csrrsi %s, %s, 0x%x", rd.syntax, csr.syntax, imm)
  image  = format("%12s%5s110%5s1110011", csr.image, imm, rd.image)
  action = {
    if imm != 0 then
      csr = csr | zero_extend(XWORD, imm);
    endif;
    rd = zero_extend(XWORD, csr);
  }

op csrrci(rd: X, csr: CSR_MODE, imm: card(5))
  syntax = format("csrrci %s, %s, 0x%x", rd.syntax, csr.syntax, imm)
  image  = format("%12s%5s111%5s1110011", csr.image, imm, rd.image)
  action = {
    if imm != 0 then
      csr = csr & ~zero_extend(XWORD, imm);
    endif;
    rd = zero_extend(XWORD, csr);
  }

//==================================================================================================
// Pseudoinstructions
//==================================================================================================

// Write CSR
pseudo op csrw(csr: CSR_MODE, rs1: X)
  syntax = format("csrw %s, %s", csr.syntax, rs1.syntax)
  image  = format("%32s", csrrw(X(0), csr, rs1).image)
  action = {
    csrrw(X(0), csr, rs1).action;
  }

// Read CSR
pseudo op csrr(rd: X, csr: CSR_MODE)
  syntax = format("csrr %s, %s", rd.syntax, csr.syntax)
  image  = format("%32s", csrrs(rd, csr, X(0)).image)
  action = {
    csrrs(rd, csr, X(0)).action;
  }

// Set bits in CSR
pseudo op csrs(csr: CSR_MODE, rs1: X)
  syntax = format("csrs %s, %s", csr.syntax, rs1.syntax)
  image  = format("%32s", csrrs(X(0), csr, rs1).image)
  action = {
    csrrs(X(0), csr, rs1).action;
  }

// Clear bits in CSR
pseudo op csrc(csr: CSR_MODE, rs1: X)
  syntax = format("csrc %s, %s", csr.syntax, rs1.syntax)
  image  = format("%32s", csrrc(X(0), csr, rs1).image)
  action = {
    csrrc(X(0), csr, rs1).action;
  }

// Write CSR, immediate
pseudo op csrwi(csr: CSR_MODE, imm: card(5))
  syntax = format("csrwi %s, 0x%x", csr.syntax, imm)
  image  = format("%32s", csrrwi(X(0), csr, imm).image)
  action = {
    csrrwi(X(0), csr, imm).action;
  }

// Set bits in CSR, immediate
pseudo op csrsi(csr: CSR_MODE, imm: card(5))
  syntax = format("csrsi %s, 0x%x", csr.syntax, imm)
  image  = format("%32s", csrrsi(X(0), csr, imm).image)
  action = {
    csrrsi(X(0), csr, imm).action;
  }

// Clear bits in CSR, immediate
pseudo op csrci(csr: CSR_MODE, imm: card(5))
  syntax = format("csrci %s, 0x%x", csr.syntax, imm)
  image  = format("%32s", csrrci(X(0), csr, imm).image)
  action = {
    csrrci(X(0), csr, imm).action;
  }

// Read FP control/status register
pseudo op frcsr(rd: X)
  syntax = format("frcsr %s", rd.syntax)
  image  = format("%32s", csrrs(rd, FCSR(), X(0)).image)
  action = {
    csrrs(rd, FCSR(), X(0)).action;
  }

// Swap FP control/status register
pseudo op fscsr(rd: X, rs: X)
  syntax = format("fscsr %s, %s", rd.syntax, rs.syntax)
  image  = format("%32s", csrrw(rd, FCSR(), rs).image)
  action = {
    csrrw(rd, FCSR(), rs).action;
  }

// Write FP control/status register
pseudo op fscsr2(rs: X)
  syntax = format("fscsr %s", rs.syntax)
  image  = format("%32s", csrrw(X(0), FCSR(), rs).image)
  action = {
    csrrw(X(0), FCSR(), rs).action;
  }

// Read FP rounding mode
pseudo op frrm(rd: X)
  syntax = format("frrm %s", rd.syntax)
  image  = format("%32s", csrrs(rd, FRM(), X(0)).image)
  action = {
    csrrs(rd, FRM(), X(0)).action;
  }

// Swap FP rounding mode
pseudo op fsrm(rd: X, rs: X)
  syntax = format("fsrm %s, %s", rd.syntax, rs.syntax)
  image  = format("%32s", csrrw(rd, FRM(), rs).image)
  action = {
    csrrw(rd, FRM(), rs).action;
  }

// Write FP rounding mode
pseudo op fsrm2(rs: X)
  syntax = format("fsrm %s", rs.syntax)
  image  = format("%32s", csrrw(X(0), FRM(), rs).image)
  action = {
    csrrw(X(0), FRM(), rs).action;
  }

// Swap FP rounding mode, immediate
pseudo op fsrmi(rd: X, imm: card(5))
  syntax = format("fsrmi %s, 0x%x", rd.syntax, imm)
  image  = format("%32s", csrrwi(rd, FRM(), imm).image)
  action = {
    csrrwi(rd, FRM(), imm).action;
  }

// Write FP rounding mode, immediate
pseudo op fsrmi2(imm: card(5))
  syntax = format("fsrmi 0x%x", imm)
  image  = format("%32s", csrrwi(X(0), FRM(), imm).image)
  action = {
    csrrwi(X(0), FRM(), imm).action;
  }

// Read FP exception flags
pseudo op frflags(rd: X)
  syntax = format("frflags %s", rd.syntax)
  image  = format("%32s", csrrs(rd, FFLAGS(), X(0)).image)
  action = {
    csrrs(rd, FFLAGS(), X(0)).action;
  }

// Swap FP exception flags
pseudo op fsflags(rd: X, rs: X)
  syntax = format("fsflags %s, %s", rd.syntax, rs.syntax)
  image  = format("%32s", csrrw(rd, FFLAGS(), rs).image)
  action = {
    csrrw(rd, FFLAGS(), rs).action;
  }

// Write FP exception flags
pseudo op fsflags2(rs: X)
  syntax = format("fsflags %s", rs.syntax)
  image  = format("%32s", csrrw(X(0), FFLAGS(), rs).image)
  action = {
    csrrw(X(0), FFLAGS(), rs).action;
  }

// Swap FP exception flags, immediate
pseudo op fsflagsi(rd: X, imm: card(5))
  syntax = format("fsflagsi %s, 0x%x", rd.syntax, imm)
  image  = format("%32s", csrrwi(rd, FFLAGS(), imm).image)
  action = {
    csrrwi(rd, FFLAGS(), imm).action;
  }

// Write FP exception flags, immediate
pseudo op fsflagsi2(imm: card(5))
  syntax = format("fsflagsi 0x%x", imm)
  image  = format("%32s", csrrwi(X(0), FFLAGS(), imm).image)
  action = {
    csrrwi(X(0), FFLAGS(), imm).action;
  }

/*
rdinstret[h] rd csrrs rd, instret[h], x0 Read instructions-retired counter
rdcycle[h] rd csrrs rd, cycle[h], x0 Read cycle counter
rdtime[h] rd csrrs rd, time[h], x0 Read real-time clock
*/

//==================================================================================================
// Instruction Groups
//==================================================================================================

op rv32i_system = ecall
                | ebreak
                | fence
                | fencei
                | mret
                | sret
                | uret
                | wfi
                | csrrw
                | csrrs
                | csrrc
                | csrrwi
                | csrrsi
                | csrrci

op rv32i_pseudo_system = csrw
                       | csrr
                       | csrs
                       | csrc
                       | csrwi
                       | csrsi
                       | csrci
                       | frcsr
                       | fscsr
                       | fscsr2
                       | frrm
                       | fsrm
                       | fsrm2
                       | fsrmi
                       | fsrmi2
                       | frflags
                       | fsflags
                       | fsflags2
                       | fsflagsi
                       | fsflagsi2

op rv32i_sys = rv32i_system // 10
             | rv32i_pseudo_system // 20

#endif
