/*
 * Copyright 2017 ISP RAS (http://www.ispras.ru)
 * 
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */

//==================================================================================================
// Configuration of Supported Instruction Sets
//==================================================================================================

#define RV64I

// XLEN: Width of X Registers (in bits)
// SHLEN: Number of Bits Required to Store Shift Amount for X Registers
#ifdef RV64I
  let XLEN = 64
  let SHLEN = 6
#else
  let XLEN = 32
  let SHLEN = 5
#endif

//==================================================================================================
// Types
//==================================================================================================

// Configuration-Dependent Word for X Registers
type XWORD = card(XLEN)

// Configuration-Dependent Signed Word for X Registers
type XINT = int(XLEN)

// Configuration-Dependent Double Word
type XDWORD = card(XLEN*2)

// Configuration-Dependent Signed Double Word
type XLONG = int(XLEN*2)

// Unsigned Types
type   BIT = card(1)
type  BYTE = card(8)
type HWORD = card(16)
type  WORD = card(32)
type DWORD = card(64)
type QWORD = card(128)

// Signed Types
type SHORT = int(16)
type   INT = int(32)
type  LONG = int(64)

// Floating Point Types
type FLOAT32 = float(23, 8)
type FLOAT64 = float(52, 11)

//==================================================================================================
// Registers and Memory
//==================================================================================================

// General-Purpose Registers
reg XREG [32, XWORD]

// Program Counter
reg PC [XWORD]

// Memory Size is 2 ** XLEN Bytes
let MEM_SIZE_IN_WORDS = 2 ** (XLEN - 2)

// Main Memory
shared mem MEM [MEM_SIZE_IN_WORDS, WORD]

//==================================================================================================
// Addressing Modes
//==================================================================================================

/*
"zero", "ra  ", "sp  ", "gp  ", "tp  ", "t0  ",  "t1  ",  "t2 ",
"s0  ", "s1  ", "a0  ", "a1  ", "a2  ", "a3  ",  "a4  ",  "a5 ",
"a6  ", "a7  ", "s2  ", "s3  ", "s4  ", "s5  ",  "s6  ",  "s7 ",
"s8  ", "s9  ", "s10 ", "s11 ", "t3  ", "t4  ",  "t5  ",  "t6  "
*/

// Hard-wired zero
mode ZERO () = XREG [0]
  syntax = format("zero")

// Return address
mode RA () = XREG [1]
  syntax = format("ra")

// Stack pointer
mode SP () = XREG [2]
  syntax = format("sp")

// Global pointer
mode GP () = XREG [3]
  syntax = format("gp")

// Thread pointer
mode TP () = XREG [4]
  syntax = format("tp")

// Temporaries Caller
mode TemporariesCaller (i: card(3))
  syntax = format("t%d", i)

/* Saved register Callee
x8 s0/fp Saved register/frame pointer Callee
x9 s1 Saved register Callee */
mode SavedCallee (i: card(4))
  syntax = format("s%d", i)

// Function arguments Caller
mode FunctionCaller (i: card(3))
  syntax = format("a%d", i)

mode X (i: card(5)) = XREG [i]
  syntax = format("%s", if i == 0 then ZERO().syntax
                        elif i == 1 then RA().syntax
                        elif i == 2 then SP().syntax
                        elif i == 3 then GP().syntax
                        elif i == 4 then TP().syntax
                        elif i >= 5 && i <= 7 then TemporariesCaller(coerce(card(3), i-5)).syntax
                        elif i >= 8 && i <= 9 then SavedCallee(coerce(card(4), i-8)).syntax
                        elif i >= 10 && i <= 17 then FunctionCaller(coerce(card(3), i-10)).syntax
                        elif i >= 18 && i <= 27 then SavedCallee(coerce(card(4), i-16)).syntax
                        elif i >= 28 && i <= 31 then TemporariesCaller(coerce(card(3), i-25)).syntax
                        else "error"
                        endif)
  image  = format("%5s", i)

/*f0–7 ft0–7 FP temporaries Caller
f8–9 fs0–1 FP saved registers Callee
f10–11 fa0–1 FP arguments/return values Caller
f12–17 fa2–7 FP arguments Caller
f18–27 fs2–11 FP saved registers Callee
f28–31 ft8–11 FP temporaries*/

//==================================================================================================
// Temporary Variables
//==================================================================================================

// Previous Value of the PC
var prev_pc [XWORD]

var tmp_address [XWORD]
var tmp_index [XWORD]
var tmp_byte [BYTE]
var tmp_half [HWORD]
var tmp_dword [DWORD]
var tmp_word [WORD]

// Bit Offset in a Word
var tmp_bit_offset [card(5)]

//==================================================================================================
// Instruction Types
//==================================================================================================

/*
 R-type:  |31             25|24       20|19   15|14  12|11             7|6     0|
          |     funct7      |    rs2    |  rs1  |funct3|       rd       |opcode |
          |       7         |     5     |   5   |  3   |       5        |   7   |

 I-type:  |31                         20|19   15|14  12|11             7|6     0|
          |          imm[11:0]          |  rs1  |funct3|       rd       |opcode |
          |              12             |   5   |  3   |       5        |   7   |

 S-type:  |31             25|24       20|19   15|14  12|11             7|6     0|
          |    imm[11:5]    |    rs2    |  rs1  |funct3|   imm[4:0]     |opcode |
          |       7         |     5     |   5   |  3   |       5        |   7   |

 SB-type: |31   31|30     25|24       20|19   15|14  12|11     8|7     7|6     0|
          |imm[12]|imm[10:5]|    rs2    |  rs1  |funct3|imm[4:1]|imm[11]|opcode |
          |   1   |    6    |     5     |   5   |  3   |   4    |   1   |   7   |

 U-type:  |31                                        12|11             7|6     0|
          |               imm[31:12]                   |       rd       |opcode |
          |                   20                       |       5        |   7   |

 UJ-type: |31   31|30         21|20   20|19          12|11             7|6     0|
          |imm[20]|  imm[10:1]  |imm[11]|  imm[19:12]  |       rd       |opcode |
          |   1   |     10      |   1   |       8      |       5        |   7   |
*/

//==================================================================================================
// Instruction Templates
//==================================================================================================

/*

R-type:

op <name>(rd: X, rs1: X, rs2: X)
  syntax = format("<name> %s, %s, %s", rd.syntax, rs1.syntax, rs2.syntax)
  image  = format("<func7>%s%s<func3>%s<opcode>", rs2.image, rs1.image, rd.image)
  action = {
    // TODO
  }

I-type:

op <name>(rd: X, rs1: X, imm: card(12))
  syntax = format("<name> %s, %s, 0x%x", rd.syntax, rs1.syntax, imm)
  image  = format("%12s%s<func3>%s<opcode>", imm, rs1.image, rd.image)
  action = {
    // TODO
  }

S-type:

op <name>(rs1: X, rs2: X, imm: card(12))
  syntax = format("<name> %s, %s, 0x%x", rs1.syntax, rs2.syntax, imm)
  image  = format("%7s%s%s<func3>%5s<opcode>", imm<11..5>, rs2.image, rs1.image, imm<4..0>)
  action = {
    // TODO
  }

SB-type:

op <name>(rs1: X, rs2: X, imm: card(12))
  syntax = format("<name> %s, %s, 0x%x", rs1.syntax, rs2.syntax, imm)
  image  = format("%1s%6s%s%s<func3>%4s%1s<opcode>",
                  imm<11>, imm<9..4>, rs2.image, rs1.image, imm<3..0>, imm<10>)
  action = {
    // TODO
  }

U-type:

op <name>(rd: X, imm: card(20))
  syntax = format("<name> %s, 0x%x", rd.syntax, imm)
  image  = format("%20s%s<opcode>", imm, rd.image)
  action = {
    // TODO
  }

UJ-type:

op <name>(rd: X, imm: card(20))
  syntax = format("<name> %s, 0x%x", rd.syntax, imm)
  image  = format("%1s%10s%1s%8s%s1101111", imm<19>, imm<9..0>, imm<10>, imm<18..11>, rd.image)
  action = {
    // TODO
  }
*/

//==================================================================================================
// Instructions
//==================================================================================================

#include "riscv_rv32i.nml"
#include "riscv_rv32m.nml"

#ifdef RV64I
  #include "riscv_rv64i.nml"
  #include "riscv_rv64m.nml"
#endif

op Op = rv32i
      | rv32m
#ifdef RV64I
      | rv64i
      | rv64m
#endif

op instruction(operation: Op)
  syntax = operation.syntax
  image  = operation.image
  action = {
    XREG[0] = 0;
    prev_pc = PC;

    operation.action;
    if PC == prev_pc then
      PC = PC + 4;
    endif;
  }

//==================================================================================================
// The End
//==================================================================================================
