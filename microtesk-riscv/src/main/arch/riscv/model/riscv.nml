/*
 * Copyright 2017 ISP RAS (http://www.ispras.ru)
 * 
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */

//==================================================================================================
// Configuration of Supported Instruction Sets
//==================================================================================================

// XLEN: Width of X Registers (in bits)
// SHLEN: Number of Bits Required to Store Shift Amount for X Registers
#ifdef RV64I
  let XLEN = 64
  let XLEN_RANGE = 63
  let SHLEN = 6
#else
  let XLEN = 32
  let SHLEN = 5
#endif

//==================================================================================================
// Types
//==================================================================================================

// Configuration-Dependent Word for X Registers
type XWORD = card(XLEN)

// Configuration-Dependent Signed Word for X Registers
type XINT = int(XLEN)

// Configuration-Dependent Double Word
type XDWORD = card(XLEN*2)

// Configuration-Dependent Signed Double Word
type XLONG = int(XLEN*2)

// Unsigned Types
type   BIT = card(1)
type  BYTE = card(8)
type HWORD = card(16)
type  WORD = card(32)
type DWORD = card(64)
type QWORD = card(128)

// Signed Types
type SHORT = int(16)
type   INT = int(32)
type  LONG = int(64)

// Floating Point Types
#ifdef RV32F
  type FLOAT32  = float(23, 8)
#endif
#ifdef RV64F
  type FLOAT64  = float(52, 11)
#endif
#ifdef RV64F
  type FLOATREG = FLOAT64
#else
  type FLOATREG = FLOAT32
#endif

//==================================================================================================
// Constants
//==================================================================================================

let FP_FMT_S = 0b00
let FP_FMT_D = 0b01
let FP_FMT_Q = 0b11

//==================================================================================================
// Registers and Memory
//==================================================================================================

// General-Purpose Registers
reg XREG [32, XWORD]

#ifdef RV32F
  // Floating Point general registers.
  // TODOreg FPR [32, FLOATREG]
  reg FPR [32, XWORD]
#endif

// Program Counter
reg PC [XWORD]

// Memory Size
let MEM_SIZE = XLEN - 2

// Memory Size is 2 ** XLEN Bytes
let MEM_SIZE_IN_WORDS = 2 ** (MEM_SIZE)

// Main Memory
shared mem MEM [MEM_SIZE_IN_WORDS, WORD]

// Control and status registers (CSRs)
reg CSR[0xfff, XWORD]

var csr_index[card(12)]

// User Trap Setup
// User status register
mode USTATUS() = CSR[0x000]
  init = { csr_index = 0x000; }
  syntax = format("ustatus")
  image = format("%12s", csr_index)
// User interrupt-enable register
mode UIE() = CSR[0x004]
  init = { csr_index = 0x004; }
  syntax = format("uie")
  image = format("%12s", csr_index)
// User trap handler base address
mode UTVEC() = CSR[0x005]
  init = { csr_index = 0x005; }
  syntax = format("utvec")
  image = format("%12s", csr_index)
// User Trap Handling
// Scratch register for user trap handlers
mode USCRATCH() = CSR[0x040]
  init = { csr_index = 0x040; }
  syntax = format("uscratch")
  image = format("%12s", csr_index)
// User exception program counter
mode UEPC() = CSR[0x041]
  init = { csr_index = 0x041; }
  syntax = format("uepc")
  image = format("%12s", csr_index)
// User trap cause
mode UCAUSE() = CSR[0x042]
  init = { csr_index = 0x042; }
  syntax = format("ucause")
  image = format("%12s", csr_index)
// User bad address or instruction
mode UTVAL() = CSR[0x043]
  init = { csr_index = 0x043; }
  syntax = format("utval")
  image = format("%12s", csr_index)
// User interrupt pending
mode UIP() = CSR[0x044]
  init = { csr_index = 0x044; }
  syntax = format("uip")
  image = format("%12s", csr_index)
// User Floating-Point CSRs
// Floating-Point Accrued Exceptions
mode FFLAGS() = CSR[0x001]
  init = { csr_index = 0x001; }
  syntax = format("fflags")
  image = format("%12s", csr_index)
// Floating-Point Dynamic Rounding Mode
mode FRM() = CSR[0x002]
  init = { csr_index = 0x002; }
  syntax = format("frm")
  image = format("%12s", csr_index)
// Floating-Point Control and Status Register (frm + fflags)
mode FCSR() = CSR[0x003]
  init = { csr_index = 0x003; }
  syntax = format("fcsr")
  image = format("%12s", csr_index)
// User Counter/Timers
// Cycle counter for RDCYCLE instruction
mode CYCLE() = CSR[0xC00]
  init = { csr_index = 0xC00; }
  syntax = format("cycle")
  image = format("%12s", csr_index)
// Timer for RDTIME instruction
mode TIME() = CSR[0xC01]
  init = { csr_index = 0xC01; }
  syntax = format("time")
  image = format("%12s", csr_index)
// Instructions-retired counter for RDINSTRET instruction
mode INSTRET() = CSR[0xC02]
  init = { csr_index = 0xC02; }
  syntax = format("instret")
  image = format("%12s", csr_index)

mode CSR_MODE = USTATUS | UIE | UTVEC
              | USCRATCH | UEPC | UCAUSE | UTVAL | UIP
              | FFLAGS | FRM | FCSR
              | CYCLE | TIME | INSTRET

//==================================================================================================
// Addressing Modes
//==================================================================================================

/*
"zero", "ra  ", "sp  ", "gp  ", "tp  ", "t0  ",  "t1  ",  "t2 ",
"s0  ", "s1  ", "a0  ", "a1  ", "a2  ", "a3  ",  "a4  ",  "a5 ",
"a6  ", "a7  ", "s2  ", "s3  ", "s4  ", "s5  ",  "s6  ",  "s7 ",
"s8  ", "s9  ", "s10 ", "s11 ", "t3  ", "t4  ",  "t5  ",  "t6  "
*/

// Hard-wired zero
mode ZERO () = XREG [0]
  syntax = format("zero")

// Return address
mode RA () = XREG [1]
  syntax = format("ra")

// Stack pointer
mode SP () = XREG [2]
  syntax = format("sp")

// Global pointer
mode GP () = XREG [3]
  syntax = format("gp")

// Thread pointer
mode TP () = XREG [4]
  syntax = format("tp")

// Temporaries Caller
mode TemporariesCaller (i: card(3))
  syntax = format("t%d", i)

/* Saved register Callee
x8 s0/fp Saved register/frame pointer Callee
x9 s1 Saved register Callee */
mode SavedCallee (i: card(4))
  syntax = format("s%d", i)

// Function arguments Caller
mode FunctionCaller (i: card(3))
  syntax = format("a%d", i)

mode X (i: card(5)) = XREG [i]
  syntax = format("%s", if i == 0 then ZERO().syntax
                        elif i == 1 then RA().syntax
                        elif i == 2 then SP().syntax
                        elif i == 3 then GP().syntax
                        elif i == 4 then TP().syntax
                        elif i >= 5 && i <= 7 then TemporariesCaller(coerce(card(3), i-5)).syntax
                        elif i >= 8 && i <= 9 then SavedCallee(coerce(card(4), i-8)).syntax
                        elif i >= 10 && i <= 17 then FunctionCaller(coerce(card(3), i-10)).syntax
                        elif i >= 18 && i <= 27 then SavedCallee(coerce(card(4), i-16)).syntax
                        elif i >= 28 && i <= 31 then TemporariesCaller(coerce(card(3), i-25)).syntax
                        else "error" endif)
  image  = format("%5s", i)

// FP temporaries Caller
mode FPTemporariesCaller (i: card(4))
  syntax = format("ft%d", i)

// FP temporaries Caller
mode FPSavedCallee (i: card(4))
  syntax = format("fs%d", i)

/* f10–11 fa0–1 FP arguments/return values Caller
   f12–17 fa2–7 FP arguments Caller */
mode FPArgumentsCaller (i: card(3))
  syntax = format("fa%d", i)

mode FR (i: card(5)) = FPR[i]
  syntax = format("%s", if i >= 0 && i <= 7 then FPTemporariesCaller(coerce(card(4), i)).syntax
                        elif i >= 8 && i <= 9 then FPSavedCallee(coerce(card(4), i-8)).syntax
                        elif i >= 10 && i <= 17 then FPArgumentsCaller(coerce(card(3), i-10)).syntax
                        elif i >= 18 && i <= 27 then FPSavedCallee(coerce(card(4), i-16)).syntax
                        elif i >= 28 && i <= 31 then FPTemporariesCaller(coerce(card(4), i-20)).syntax
                        else "error" endif)
  image  = format("%5s", i)

//==================================================================================================
// Temporary Variables
//==================================================================================================

// Previous Value of the PC
var prev_pc [XWORD]

var tmp_address [XWORD]
var tmp_index [XWORD]
var tmp_bit [BIT]
var tmp_byte [BYTE]
var tmp_half [HWORD]
var tmp_dword [DWORD]
var tmp_word [WORD]

var tmp_int1 [INT]
var tmp_int2 [INT]

var tmp_long1 [LONG]
var tmp_long2 [LONG]

#ifdef RV32F
  var temp_fps  [FLOAT32]
  var temp_fps2 [FLOAT32]
  var temp_fps3 [FLOAT32]
#endif
#ifdef RV64F
  var temp_fpd  [FLOAT64]
  var temp_fpd2 [FLOAT64]
  var temp_fpd3 [FLOAT64]
#endif

// Bit Offset in a Word
var tmp_bit_offset [card(5)]

//==================================================================================================
// Instruction Types
//==================================================================================================

/*
 R-type:  |31             25|24       20|19   15|14  12|11             7|6     0|
          |     funct7      |    rs2    |  rs1  |funct3|       rd       |opcode |
          |       7         |     5     |   5   |  3   |       5        |   7   |

 I-type:  |31                         20|19   15|14  12|11             7|6     0|
          |          imm[11:0]          |  rs1  |funct3|       rd       |opcode |
          |              12             |   5   |  3   |       5        |   7   |

 S-type:  |31             25|24       20|19   15|14  12|11             7|6     0|
          |    imm[11:5]    |    rs2    |  rs1  |funct3|   imm[4:0]     |opcode |
          |       7         |     5     |   5   |  3   |       5        |   7   |

 SB-type: |31   31|30     25|24       20|19   15|14  12|11     8|7     7|6     0|
          |imm[12]|imm[10:5]|    rs2    |  rs1  |funct3|imm[4:1]|imm[11]|opcode |
          |   1   |    6    |     5     |   5   |  3   |   4    |   1   |   7   |

 U-type:  |31                                        12|11             7|6     0|
          |               imm[31:12]                   |       rd       |opcode |
          |                   20                       |       5        |   7   |

 UJ-type: |31   31|30         21|20   20|19          12|11             7|6     0|
          |imm[20]|  imm[10:1]  |imm[11]|  imm[19:12]  |       rd       |opcode |
          |   1   |     10      |   1   |       8      |       5        |   7   |
*/

var opcode_xtype[card(7)]
var funct3[card(3)]
var funct7[card(7)]

//==================================================================================================
// Instruction Templates
//==================================================================================================

/*

R-type:

op <name>(rd: X, rs1: X, rs2: X)
  syntax = format("<name> %s, %s, %s", rd.syntax, rs1.syntax, rs2.syntax)
  image  = format("<func7>%s%s<func3>%s<opcode>", rs2.image, rs1.image, rd.image)
  action = {
    // TODO
  }

I-type:

op <name>(rd: X, rs1: X, imm: card(12))
  syntax = format("<name> %s, %s, 0x%x", rd.syntax, rs1.syntax, imm)
  image  = format("%12s%s<func3>%s<opcode>", imm, rs1.image, rd.image)
  action = {
    // TODO
  }

S-type:

op <name>(rs1: X, rs2: X, imm: card(12))
  syntax = format("<name> %s, %s, 0x%x", rs1.syntax, rs2.syntax, imm)
  image  = format("%7s%s%s<func3>%5s<opcode>", imm<11..5>, rs2.image, rs1.image, imm<4..0>)
  action = {
    // TODO
  }

SB-type:

op <name>(rs1: X, rs2: X, imm: card(12))
  syntax = format("<name> %s, %s, 0x%x", rs1.syntax, rs2.syntax, imm)
  image  = format("%1s%6s%s%s<func3>%4s%1s<opcode>",
                  imm<11>, imm<9..4>, rs2.image, rs1.image, imm<3..0>, imm<10>)
  action = {
    // TODO
  }

U-type:

op <name>(rd: X, imm: card(20))
  syntax = format("<name> %s, 0x%x", rd.syntax, imm)
  image  = format("%20s%s<opcode>", imm, rd.image)
  action = {
    // TODO
  }

UJ-type:

op <name>(rd: X, imm: card(20))
  syntax = format("<name> %s, 0x%x", rd.syntax, imm)
  image  = format("%1s%10s%1s%8s%s1101111", imm<19>, imm<9..0>, imm<10>, imm<18..11>, rd.image)
  action = {
    // TODO
  }
*/

//==================================================================================================
// General functions
//==================================================================================================
#ifdef RV32A
  #define LOAD_STORE_MEM
#endif
#ifdef RV32F
  #define LOAD_STORE_MEM
  #define ROUNDING_MODE_ON
#endif

#ifdef LOAD_STORE_MEM
let MEM_DWORD = 8
let MEM_WORD  = 4
let MEM_HWORD = 2
let MEM_BYTE  = 1

var temp_address_load[DWORD]
var temp_address_tail[card(2)]

pseudo op check_aligned(op_type: card(4), address: XWORD)
  action = {
    if (op_type == MEM_DWORD && address<2..0> != 0) ||
       (op_type == MEM_WORD && address<1..0> != 0) ||
       (op_type == MEM_HWORD && address<0> != 0) then
      trace("For best performance, the effective address for all loads and stores should be");
      trace("naturally aligned for each data type");
      exception("Address Error: rv32a");
      tmp_bit = 1;
    endif;
  }

var load_value[DWORD]

pseudo op load_data(op_type: card(4), address: XWORD)
  action = {
    tmp_bit = 0;
    check_aligned(op_type, address).action;
    if tmp_bit != 1 then
      if op_type == MEM_DWORD then
        load_value<63..0> = MEM[address >> 2 + 1]::MEM[address >> 2];
      elif op_type == MEM_WORD then
        load_value = 0;
        load_value<31..0> = MEM[address >> 2];
      endif;
    endif;
  }

pseudo op store_data(op_type: card(4), address: XWORD, store_value: DWORD)
  action = {
    tmp_bit = 0;
    check_aligned(op_type, address).action;
    if tmp_bit != 1 then
      if op_type == MEM_DWORD then
        MEM[address >> 2 + 1]::MEM[address >> 2] = store_value;
      elif op_type == MEM_WORD then
        MEM[address >> 2] = store_value<31..0>;
      endif;
    endif;
  }
#endif

#ifdef ROUNDING_MODE_ON
var RoundingMode [card(3)] // TODO:

//Round to Nearest, ties to Even
let RM_RNE = 0x000
// 001 RTZ Round towards Zero
let RM_RTZ = 0x001
// 010 RDN Round Down (towards -infinity)
let RM_RDN = 0x010
// 011 RUP Round Up (towards +infinity)
let RM_RUP = 0x011
// 100 RMM Round to Nearest, ties to Max Magnitude
let RM_RMM = 0x100
#endif

//==================================================================================================
// Instructions
//==================================================================================================

#include "riscv_rv32i.nml"
#ifdef RV32M
    #include "riscv_rv32m.nml"
#endif
#ifdef RV32A
    #include "riscv_rv32a.nml"
#endif
#ifdef RV32F
    #include "riscv_rv32f.nml"
#endif

#ifdef RV64I
  #include "riscv_rv64i.nml"
#endif
#ifdef RV64M
  #include "riscv_rv64m.nml"
#endif
#ifdef RV64A
  #include "riscv_rv64a.nml"
#endif
#ifdef RV64F
  #include "riscv_rv64f.nml"
#endif
#ifdef RV32D
  #include "riscv_rv32d.nml"
#endif
#ifdef RV64D
  #include "riscv_rv64d.nml"
#endif

op Op = rv32i // 47 + 36
#ifdef RV32M
      | rv32m // 8
#endif
#ifdef RV32A
      | rv32a // 11
#endif
#ifdef RV32F
      | rv32f // 26 + 3
#endif
#ifdef RV32D
      | rv32d // 26 + 3
#endif
#ifdef RV64I
      | rv64i // 12
#endif
#ifdef RV64M
      | rv64m // 5
#endif
#ifdef RV64A
      | rv64a // 11
#endif
#ifdef RV64F
      | rv64f // 4
#endif
#ifdef RV64D
      | rv64d // 6
#endif
//pseudo +15
// Total: (47+77+32)+(36+3+3)+15 = 213

op instruction(operation: Op)
  syntax = operation.syntax
  image  = operation.image
  action = {
    XREG[0] = 0;
    prev_pc = PC;

    operation.action;
    if PC == prev_pc then
      PC = PC + 4;
    endif;
  }

//==================================================================================================
// Special pseudoinstructions
//==================================================================================================

#include "riscv_pseudo.nml"

//==================================================================================================
// The End
//==================================================================================================
