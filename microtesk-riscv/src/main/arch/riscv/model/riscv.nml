/*
 * Copyright 2017 ISP RAS (http://www.ispras.ru)
 * 
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */

//==================================================================================================
// Configuration of Supported Instruction Sets
//==================================================================================================

#define RV64I

// XLEN: Width of X Registers (in bits)
// SHLEN: Number of Bits Required to Store Shift Amount for X Registers
#ifdef RV64I
  let XLEN = 64
  let SHLEN = 6
#else
  let XLEN = 32
  let SHLEN = 5
#endif

//==================================================================================================
// Types
//==================================================================================================

// Configuration-Dependent Word for X Registers
type XWORD = card(XLEN)

// Configuration-Dependent Signed Word for X Registers
type XINT = int(XLEN)

// Unsigned Types
type   BIT = card(1)
type  BYTE = card(8)
type HWORD = card(16)
type  WORD = card(32)
type DWORD = card(64)
type QWORD = card(128)

// Signed Types
type SHORT = int(16)
type   INT = int(32)
type  LONG = int(64)

// Floating Point Types
type FLOAT32 = float(23, 8)
type FLOAT64 = float(52, 11)

//==================================================================================================
// Registers and Memory
//==================================================================================================

// General-Purpose Registers
reg XREG [32, XWORD]

// Program Counter
reg PC [XWORD]

// Memory Size is 2 ** XLEN Bytes
let MEM_SIZE_IN_WORDS = 2 ** (XLEN - 2)

// Main Memory
shared mem MEM [MEM_SIZE_IN_WORDS, WORD]

//==================================================================================================
// Addressing Modes
//==================================================================================================

mode X (i: card(5)) = XREG [i]
  syntax = format("x%d", i)
  image  = format("%5s", i)

//==================================================================================================
// Instruction Types
//==================================================================================================

/*
 R-type:  |31             25|24       20|19   15|14  12|11             7|6     0|
          |     funct7      |    rs2    |  rs1  |funct3|       rd       |opcode |
          |       7         |     5     |   5   |  3   |       5        |   7   |

 I-type:  |31                         20|19   15|14  12|11             7|6     0|
          |          imm[11:0]          |  rs1  |funct3|       rd       |opcode |
          |              12             |   5   |  3   |       5        |   7   |

 S-type:  |31             25|24       20|19   15|14  12|11             7|6     0|
          |    imm[11:5]    |    rs2    |  rs1  |funct3|   imm[4:0]     |opcode |
          |       7         |     5     |   5   |  3   |       5        |   7   |

 SB-type: |31   31|30     25|24       20|19   15|14  12|11     8|7     7|6     0|
          |imm[12]|imm[10:5]|    rs2    |  rs1  |funct3|imm[4:1]|imm[11]|opcode |
          |   1   |    6    |     5     |   5   |  3   |   4    |   1   |   7   |

 U-type:  |31                                        12|11             7|6     0|
          |               imm[31:12]                   |       rd       |opcode |
          |                   20                       |       5        |   7   |

 UJ-type: |31   31|30         21|20   20|19          12|11             7|6     0|
          |imm[20]|  imm[10:1]  |imm[11]|  imm[19:12]  |       rd       |opcode |
          |   1   |     10      |   1   |       8      |       5        |   7   |
*/

//==================================================================================================
// Instruction Templates
//==================================================================================================

/*

R-type:

op <name>(rd: X, rs1: X, rs2: X)
  syntax = format("<name> %s, %s, %s", rd.syntax, rs1.syntax, rs2.syntax)
  image  = format("<func7>%s%s<func3>%s<opcode>", rs2.image, rs1.image, rd.image)
  action = {
    // TODO
  }

I-type:

op <name>(rd: X, rs1: X, imm: card(12))
  syntax = format("<name> %s, %s, 0x%x", rd.syntax, rs1.syntax, imm)
  image  = format("%12s%s<func3>%s<opcode>", imm, rs1.image, rd.image)
  action = {
    // TODO
  }

SB-type:

op <name>(rs1: X, rs2: X, imm: card(12))
  syntax = format("<name> %s, %s, 0x%x", rs1.syntax, rs2.syntax, imm)
  image  = format("%1s%6s%s%s<func3>%4s%1s<opcode>",
                  imm<11>, imm<9..4>, rs2.image, rs1.image, imm<3..0>, imm<10>)
  action = {
    // TODO
  }

U-type:

op <name>(rd: X, imm: card(20))
  syntax = format("<name> %s, 0x%x", rd.syntax, imm)
  image  = format("%20s%s<opcode>", imm, rd.image)
  action = {
    // TODO
  }

UJ-type:

op <name>(rd: X, imm: card(20))
  syntax = format("<name> %s, 0x%x", rd.syntax, imm)
  image  = format("%1s%10s%1s%8s%s1101111", imm<19>, imm<9..0>, imm<10>, imm<18..11>, rd.image)
  action = {
    // TODO
  }
*/

//==================================================================================================
// Instructions
//==================================================================================================

#include "riscv_rv32i.nml"

op Op = rv32i

// Temporary Variable to Store Previous Value of PC
var PREV_PC [XWORD]

op instruction (operation: Op)
  syntax = operation.syntax
  image  = operation.image
  action = {
    XREG[0] = 0;
    PREV_PC = PC;

    operation.action;
    if PC == PREV_PC then
      PC = PC + 4;
    endif;
  }

//==================================================================================================
// The End
//==================================================================================================
