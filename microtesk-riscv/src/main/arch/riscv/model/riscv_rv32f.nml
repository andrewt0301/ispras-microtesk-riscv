/*
 * Copyright 2017 ISP RAS (http://www.ispras.ru)
 * 
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */

#ifndef RISCV_RV32F_INCLUDED
#define RISCV_RV32F_INCLUDED

//==================================================================================================
// RV32F Standard Extension
//==================================================================================================

/*  FLW
FSW
FMADD.S
FMSUB.S
FNMSUB.S
FNMADD.S
FADD.S
FSUB.S
FMUL.S
FDIV.S
FSQRT.S
FSGNJ.S
FSGNJN.S
FSGNJX.S
FMIN.S
FMAX.S
FCVT.W.S
FCVT.WU.S
FMV.X.S
FEQ.S
FLT.S
FLE.S
FCLASS.S
FCVT.S.W
FCVT.S.WU
FMV.S.X */

var RoundingMode [card(3)] // TODO:

//Round to Nearest, ties to Even
let RM_RNE = 0x000
// 001 RTZ Round towards Zero
let RM_RTZ = 0x001
// 010 RDN Round Down (towards -infinity)
let RM_RDN = 0x010
// 011 RUP Round Up (towards +infinity)
let RM_RUP = 0x011
// 100 RMM Round to Nearest, ties to Max Magnitude
let RM_RMM = 0x100

op flw(rd: FR, rs1: X, imm: card(12))
  syntax = format("flw %s, 0x%x(%s)", rd.syntax, imm, rs1.syntax)
  image  = format("%12s%s010%s0000111", imm, rs1.image, rd.image)
  action = {
    tmp_address = rs1 + sign_extend(XWORD, imm);
    load_data(MEM_WORD, tmp_address).action; // return load_value
    rd = 0;
    rd<31..0> = load_value<31..0>;
  }

op fsw(rs2: FR, rs1: X, imm: card(12))
  syntax = format("fsw %s, 0x%x(%s)", rs2.syntax, imm, rs1.syntax)
  image  = format("%7s%5s%5s010%5s0100111", imm<11..5>, rs2.image, rs1.image, imm<4..0>)
  action = {
    tmp_address = rs1 + sign_extend(XWORD, imm);
    store_data(MEM_WORD, tmp_address, zero_extend(DWORD, rs2<31..0>)).action;
  }

op fadd_s(rd: FR, rs1: FR, rs2: FR)
  syntax = format("fadd.s %s, %s, %s", rd.syntax, rs1.syntax, rs2.syntax)
  image  = format("0000000%s%s%3s%s1010011", rs2.image, rs1.image, coerce(card(3), RM_RNE), rd.image)
  action = {
    temp_fps = int_to_float(FLOAT32, rs1<31..0>) + int_to_float(FLOAT32, rs2<31..0>);
    rd = 0;
    rd<31..0> = float_to_int(WORD, temp_fps);
  }

op fsub_s(rd: FR, rs1: FR, rs2: FR)
  syntax = format("fsub.s %s, %s, %s", rd.syntax, rs1.syntax, rs2.syntax)
  image  = format("0000100%s%s%3s%s1010011", rs2.image, rs1.image, coerce(card(3), RM_RNE), rd.image)
  action = {
    temp_fps = int_to_float(FLOAT32, rs1<31..0>) - int_to_float(FLOAT32, rs2<31..0>);
    rd = 0;
    rd<31..0> = float_to_int(WORD, temp_fps);
  }

op fmul_s(rd: FR, rs1: FR, rs2: FR)
  syntax = format("fmul.s %s, %s, %s", rd.syntax, rs1.syntax, rs2.syntax)
  image  = format("0001000%s%s%3s%s1010011", rs2.image, rs1.image, coerce(card(3), RM_RNE), rd.image)
  action = {
    temp_fps = int_to_float(FLOAT32, rs1<31..0>) * int_to_float(FLOAT32, rs2<31..0>);
    rd = 0;
    rd<31..0> = float_to_int(WORD, temp_fps);
  }

op fdiv_s(rd: FR, rs1: FR, rs2: FR)
  syntax = format("fdiv.s %s, %s, %s", rd.syntax, rs1.syntax, rs2.syntax)
  image  = format("0001100%s%s%3s%s1010011", rs2.image, rs1.image, coerce(card(3), RM_RNE), rd.image)
  action = {
    temp_fps = int_to_float(FLOAT32, rs1<31..0>) * int_to_float(FLOAT32, rs2<31..0>);
    rd = 0;
    rd<31..0> = float_to_int(WORD, temp_fps);
  }

//==================================================================================================

op rv32f = flw
         | fsw
         | fadd_s
         | fsub_s
         | fmul_s
         | fdiv_s

//==================================================================================================

#endif