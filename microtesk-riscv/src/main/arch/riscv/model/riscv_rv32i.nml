/*
 * Copyright 2017 ISP RAS (http://www.ispras.ru)
 * 
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */

#ifndef RISCV_RV32I_INCLUDED
#define RISCV_RV32I_INCLUDED

//==================================================================================================
// RV32I Base Instruction Set
//==================================================================================================

/*
  Instructions (number: 47):
    LUI +
    AUIPC +
    JAL
    JALR
    BEQ
    BNE
    BLT
    BGE
    BLTU
    BGEU
    LB
    LH
    LW
    LBU
    LHU
    SB
    SH
    SW
    ADDI +
    SLTI +
    SLTIU +
    XORI +
    ORI +
    ANDI +
    SLLI +
    SRLI +
    SRAI +
    SLL +
    SRL +
    SRA +
    ADD +
    SUB +
    SLT +
    SLTU +
    XOR +
    OR +
    AND +
    FENCE
    FENCE.I
    ECALL
    EBREAK
    CSRRW
    CSRRS
    CSRRC
    CSRRWI
    CSRRSI
    CSRRCI

  Pseudoinstructions (number: 8):
    NOP +
    MV +
    NOT +
    NEG +
    SEQZ +
    SNEZ +
    SLTZ +
    SGTZ +
*/

//==================================================================================================

/*
  LUI : Load Upper Immediate (U-type)

  Format: lui rd, imm

  RV32I:

  LUI (load upper immediate) is used to build 32-bit constants and uses the U-type
  format. LUI places the U-immediate value in the top 20 bits of the destination
  register rd, filling in the lowest 12 bits with zeros.

  RV64I:

  LUI (load upper immediate) uses the same opcode as RV32I. LUI places the 20-bit
  U-immediate into bits 31–12 of register rd and places zero in the lowest 12 bits.
  The 32-bit result is sign-extended to 64 bits.
*/
op lui(rd: X, imm: card(20))
  syntax = format("lui %s, 0x%x", rd.syntax, imm)
  image  = format("%20s%s0110111", imm, rd.image)
  action = {
    rd = sign_extend(XWORD, imm) << 12;
  }

/*
  AUIPC : Add Upper Immediate to PC (U-type)

  Format: auipc rd, imm

  RV32I:

  AUIPC (add upper immediate to pc) is used to build pc-relative addresses and uses
  the U-type format. AUIPC forms a 32-bit offset from the 20-bit U-immediate, filing
  in the lowest 12 bits with zeros, adds this offset to the pc, then places the result
  in register rd.

  RV64I:

  AUIPC (add upper immediate to pc) uses the same opcode as RV32I. AUIPC is used to
  build pc-relative addresses and uses the U-type format. AUIPC appends 12 low-order
  zero bits to the 20-bit U-immediate, sign-extends the result to 64 bits, then adds
  it to the pc and places the result in register rd.
*/
op auipc(rd: X, imm: card(20))
  syntax = format("auipcs %s, 0x%x", rd.syntax, imm)
  image  = format("%20s%s0010111", imm, rd.image)
  action = {
    rd = PC + (sign_extend(XWORD, imm) << 12);
  }

/*
  ADDI: Add Immediate (I-type)

  Format: addi rd, rs1, imm

  ADDI adds the sign-extended 12-bit immediate to register rs1. Arithmetic overﬂow is
  ignored and the result is simply the low XLEN bits of the result. ADDI rd, rs1, 0
  is used to implement the MV rd, rs1 assembler pseudo-instruction.
*/
op addi(rd: X, rs1: X, imm: card(12))
  syntax = format("addi %s, %s, 0x%x", rd.syntax, rs1.syntax, imm)
  image  = format("%12s%s000%s0010011", imm, rs1.image, rd.image)
  action = {
    rd = rs1 + sign_extend(XWORD, imm);
  }

/*
  SLTI: Set Less Than Immediate (I-type)

  Format: slti rd, rs1, imm

  SLTI (set less than immediate) places the value 1 in register rd if register rs1 is
  less than the sign-extended immediate when both are treated as signed numbers,
  else 0 is written to rd.
*/
op slti(rd: X, rs1: X, imm: card(12))
  syntax = format("slti %s, %s, 0x%x", rd.syntax, rs1.syntax, imm)
  image  = format("%12s%s010%s0010011", imm, rs1.image, rd.image)
  action = {
    if cast(XINT, rs1) < sign_extend(XINT, imm) then
      rd = 1;
    else
      rd = 0;
    endif;
  }

/*
  SLTIU: Set Less Than Immediate Unsigned (I-type)

  Format: sltiu rd, rs1, imm

  SLTIU is similar to SLTI but compares the values as unsigned numbers (i.e.,
  the immediate is first sign-extended to XLEN bits then treated as an unsigned number).
  Note, SLTIU rd, rs1, 1 sets rd to 1 if rs1 equals zero, otherwise sets rd to 0
  (assembler pseudo-op SEQZ rd, rs).
*/
op sltiu(rd: X, rs1: X, imm: card(12))
  syntax = format("sltiu %s, %s, 0x%x", rd.syntax, rs1.syntax, imm)
  image  = format("%12s%s011%s0010011", imm, rs1.image, rd.image)
  action = {
    if rs1 < sign_extend(XWORD, imm) then
      rd = 1;
    else
      rd = 0;
    endif;
  }

/*
  XORI: XOR Immediate (I-type)

  Format: xori rd, rs1, imm

  XORI is a logical operation that performs bitwise XOR on register rs1 and
  the sign-extended 12-bit immediate and place the result in rd.
  Note, XORI rd, rs1, -1 performs a bitwise logical inversion of register rs1
  (assembler pseudo-instruction NOT rd, rs).
*/
op xori(rd: X, rs1: X, imm: card(12))
  syntax = format("xori %s, %s, 0x%x", rd.syntax, rs1.syntax, imm)
  image  = format("%12s%s100%s0010011", imm, rs1.image, rd.image)
  action = {
    rd = rs1 ^ sign_extend(XWORD, imm);
  }

/*
  ORI: OR Immediate (I-type)

  Format: ori rd, rs1, imm

  ORI is a logical operation that performs bitwise OR on register rs1
  and the sign-extended 12-bit immediate and place the result in rd.
*/
op ori(rd: X, rs1: X, imm: card(12))
  syntax = format("ori %s, %s, 0x%x", rd.syntax, rs1.syntax, imm)
  image  = format("%12s%s110%s0010011", imm, rs1.image, rd.image)
  action = {
    rd = rs1 | sign_extend(XWORD, imm);
  }

/*
  ANDI: AND Immediate (I-type)

  Format: andi rd, rs1, imm

  ANDI is a logical operation that performs bitwise AND on register rs1
  and the sign-extended 12-bit immediate and place the result in rd.
*/
op andi(rd: X, rs1: X, imm: card(12))
  syntax = format("andi %s, %s, 0x%x", rd.syntax, rs1.syntax, imm)
  image  = format("%12s%s111%s0010011", imm, rs1.image, rd.image)
  action = {
    rd = rs1 & sign_extend(XWORD, imm);
  }


/*
  SLLI: Shift Left Logical Immediate (I-type)
  SRLI: Shift Right Logical Immediate (I-type)
  SRAI: Shift Right Arithmetic Immediate (I-type)

  Format: slli rd, rs1, imm
  Format: srli rd, rs1, imm
  Format: srai rd, rs1, imm

  SLLI is a logical left shift (zeros are shifted into the lower bits).
  SRLI is a logical right shift (zeros are shifted into the upper bits).
  SRAI is an arithmetic right shift (the original sign bit is copied into the vacated upper bits).

  RV32I:

  Shifts by a constant are encoded as a specialization of the I-type format. The operand
  to be shifted is in rs1, and the shift amount is encoded in the lower 5 bits (SHLEN = 5)
  of the I-immediate ﬁeld. The right shift type is encoded in a high bit of the I-immediate.

  RV64I:

  Shifts by a constant are encoded as a specialization of the I-type format using the same
  instruction opcode as RV32I. The operand to be shifted is in rs1, and the shift amount
  is encoded in the lower 6 bits (SHLEN = 6) of the I-immediate ﬁeld for RV64I. The right
  shift type is  encoded in bit 30. For RV32I, SLLI, SRLI, and SRAI generate an illegal
  instruction exception if imm[5] = 0.
*/
op slli(rd: X, rs1: X, imm: card(SHLEN))
  syntax = format("slli %s, %s, 0x%x", rd.syntax, rs1.syntax, imm)
  image  = format("000000%1s%5s%s001%s0010011",
                  if SHLEN == 6 then imm<5> else coerce(BIT, 0) endif,
                  if SHLEN == 5 then imm else imm<4..0> endif,
                  rs1.image,
                  rd.image
                  )
  action = {
    rd = rs1 << imm;
  }

op srli(rd: X, rs1: X, imm: card(SHLEN))
  syntax = format("srli %s, %s, 0x%x", rd.syntax, rs1.syntax, imm)
  image  = format("000000%1s%5s%s101%s0010011",
                   if SHLEN == 6 then imm<5> else coerce(BIT, 0) endif,
                   if SHLEN == 5 then imm else imm<4..0> endif,
                   rs1.image,
                   rd.image
                   )
  action = {
    rd = rs1 >> imm;
  }

op srai(rd: X, rs1: X, imm: card(SHLEN))
  syntax = format("srai %s, %s, 0x%x", rd.syntax, rs1.syntax, imm)
  image  = format("010000%1s%5s%s101%s0010011",
                  if SHLEN == 6 then imm<5> else coerce(BIT, 0) endif,
                  if SHLEN == 5 then imm else imm<4..0> endif,
                  rs1.image,
                  rd.image
                  )
  action = {
    rd = cast(XINT, rs1) >> imm;
  }

/*
  SLL: Shift Left Logical (R-type)
  SRL: Shift Right Logical (R-type)
  SRA: Shift Right Arithmetic (R-type)

  Format: sll rd, rs1, rs2
          srl rd, rs1, rs2
          sra rd, rs1, rs2

  SLL, SRL, and SRA perform logical left, logical right, and arithmetic right shifts on
  the value in register rs1 by the shift amount held in register rs2.

  RV32I: The shift amount is held in the lower 5 bits of register rs2 (SHLEN = 5).
  RV64I: Only the low 6 bits of rs2 are considered for the shift amount (SHLEN = 6).
*/
op sll(rd: X, rs1: X, rs2: X)
  syntax = format("sll %s, %s, %s", rd.syntax, rs1.syntax, rs2.syntax)
  image  = format("0000000%s%s001%s0110011", rs2.image, rs1.image, rd.image)
  action = {
    rd = rs1 << rs2<SHLEN-1..0>;
  }

op srl(rd: X, rs1: X, rs2: X)
  syntax = format("srl %s, %s, %s", rd.syntax, rs1.syntax, rs2.syntax)
  image  = format("0000000%s%s101%s0110011", rs2.image, rs1.image, rd.image)
  action = {
    rd = rs1 >> rs2<SHLEN-1..0>;
  }

op sra(rd: X, rs1: X, rs2: X)
  syntax = format("sra %s, %s, %s", rd.syntax, rs1.syntax, rs2.syntax)
  image  = format("0100000%s%s101%s0110011", rs2.image, rs1.image, rd.image)
  action = {
    rd = cast(XINT, rs1) >> rs2<SHLEN-1..0>;
  }

/*
  ADD and SUB (R-type)

  Format: add rd, rs1, rs2
          sub rd, rs1, rs2

  ADD and SUB perform addition and subtraction respectively. Overﬂows are ignored
  and the low XLEN bits of results are written to the destination.
*/
op add(rd: X, rs1: X, rs2: X)
  syntax = format("add %s, %s, %s", rd.syntax, rs1.syntax, rs2.syntax)
  image  = format("0000000%s%s000%s0110011", rs2.image, rs1.image, rd.image)
  action = {
    rd = rs1 + rs2;
  }

op sub(rd: X, rs1: X, rs2: X)
  syntax = format("sub %s, %s, %s", rd.syntax, rs1.syntax, rs2.syntax)
  image  = format("0100000%s%s000%s0110011", rs2.image, rs1.image, rd.image)
  action = {
    rd = rs1 - rs2;
  }

/*
  SLT and SLTU: Set Less Than and Set Less Than Unsigned (R-type)

  Format: slt rd, rs1, rs2
          sltu rd, rs1, rs2

  SLT and SLTU  perform signed and unsigned compares respectively, writing 1 to
  rd if rs1 < rs2, 0 otherwise. Note, SLTU rd, x0, rs2 sets rd to 1 if rs2 is not
  equal to zero, otherwise sets rd to zero (assembler pseudo-op SNEZ rd, rs).
*/
op slt(rd: X, rs1: X, rs2: X)
  syntax = format("slt %s, %s, %s", rd.syntax, rs1.syntax, rs2.syntax)
  image  = format("0000000%s%s010%s0110011", rs2.image, rs1.image, rd.image)
  action = {
    if cast(XINT, rs1) < cast(XINT, rs2) then
      rd = 1;
    else
      rd = 0;
    endif;
  }

op sltu(rd: X, rs1: X, rs2: X)
  syntax = format("sltu %s, %s, %s", rd.syntax, rs1.syntax, rs2.syntax)
  image  = format("0000000%s%s011%s0110011", rs2.image, rs1.image, rd.image)
  action = {
    if rs1 < rs2 then
      rd = 1;
    else
      rd = 0;
    endif;
  }

/*
  AND, OR, and XOR (R-type)

  Format: and rd, rs1, rs2
          or rd, rs1, rs2
          xor rd, rs1, rs2

  AND, OR, and XOR perform bitwise logical operations.
*/
op and(rd: X, rs1: X, rs2: X)
  syntax = format("and %s, %s, %s", rd.syntax, rs1.syntax, rs2.syntax)
  image  = format("0000000%s%s111%s0110011", rs2.image, rs1.image, rd.image)
  action = {
    rd = rs1 & rs2;
  }

op or(rd: X, rs1: X, rs2: X)
  syntax = format("or %s, %s, %s", rd.syntax, rs1.syntax, rs2.syntax)
  image  = format("0000000%s%s110%s0110011", rs2.image, rs1.image, rd.image)
  action = {
    rd = rs1 | rs2;
  }

op xor(rd: X, rs1: X, rs2: X)
  syntax = format("xor %s, %s, %s", rd.syntax, rs1.syntax, rs2.syntax)
  image  = format("0000000%s%s100%s0110011", rs2.image, rs1.image, rd.image)
  action = {
    rd = rs1 ^ rs2;
  }

//==================================================================================================

/*
  NOP: No operation (addi x0, x0, 0)

  Format: nop

  The NOP instruction does not change any user-visible state, except for advancing
  the pc. NOP is encoded as ADDI x0, x0, 0.
*/
pseudo op nop()
  syntax = "nop"
  image  = format("%s", addi(X(0), X(0), 0).image)
  action = {
    addi(X(0), X(0), 0).action;
  }

/*
  MV: Copy register (addi rd, rs, 0)

  Format: mv rd, rs
*/
pseudo op mv(rd: X, rs: X)
  syntax = format("mv %s, %s", rd.syntax, rs.syntax)
  image  = format("%s", addi(rs, rd, 0).image)
  action = {
    addi(rd, rs, 0).action;
  }

/*
  NOT: One's complement (xori rd, rs, -1)

  Format: not rd, rs
*/
pseudo op not(rd: X, rs: X)
  syntax = format("not %s, %s", rd.syntax, rs.syntax)
  image  = format("%s", xori(rs, rd, -1).image)
  action = {
    xori(rs, rd, -1).action;
  }

/*
  NEG: Two's complement (sub rd, x0, rs)

  Format: neg rd, rs
*/
pseudo op neg(rd: X, rs: X)
  syntax = format("neg %s, %s", rd.syntax, rs.syntax)
  image  = format("%s", sub(rd, X(0), rs).image)
  action = {
    sub(rd, X(0), rs).action;
  }

/*
  SEQZ: Set if = zero (sltiu rd, rs, 1)

  Format: seqz rd, rs
*/
pseudo op seqz(rd: X, rs: X)
  syntax = format("seqz %s, %s", rd.syntax, rs.syntax)
  image  = format("%s", sltiu(rd, rs, 1).image)
  action = {
    sltiu(rd, rs, 1).action;
  }

/*
  SNEZ: Set if != zero (sltu rd, x0, rs)

  Format: snez rd, rs
*/
pseudo op snez(rd: X, rs: X)
  syntax = format("snez %s, %s", rd.syntax, rs.syntax)
  image  = format("%s", sltu(rd, X(0), rs).image)
  action = {
    sltu(rd, X(0), rs).action;
  }

/*
  SLTZ: Set if < zero (slt rd, rs, x0)

  Format: sltz rd, rs
*/
pseudo op sltz(rd: X, rs: X)
  syntax = format("sltz %s, %s", rd.syntax, rs.syntax)
  image  = format("%s", slt(rd, rs, X(0)).image)
  action = {
    slt(rd, rs, X(0)).action;
  }

/*
  SGTZ: Set if > zero (slt rd, x0, rs)

  Format: sgtz rd, rs
*/
pseudo op sgtz(rd: X, rs: X)
  syntax = format("sgtz %s, %s", rd.syntax, rs.syntax)
  image  = format("%s", slt(rd, X(0), rs).image)
  action = {
    slt(rd, X(0), rs).action;
  }

//==================================================================================================

op rv32i = lui
         | auipc
/*
         | jal
         | jalr
         | beq
         | bne
         | blt
         | bge
         | bltu
         | bgeu
         | lb
         | lh
         | lw
         | lbu
         | lhu
         | sb
         | sh
         | sw
*/
         | addi
         | slti
         | sltiu
         | xori
         | ori
         | andi
         | slli
         | srli
         | srai
         | sll
         | srl
         | sra
         | add
         | sub
         | slt
         | sltu
         | xor
         | or
         | and
/*
         | fence
         | fence.i
         | ecall
         | ebreak
         | csrrw
         | csrrs
         | csrrc
         | csrrwi
         | csrrsi
         | csrrci
*/
         // Pseudoinstructions
         | nop
         | mv
         | not
         | neg
         | seqz
         | snez
         | sltz
         | sgtz

//==================================================================================================
// The End
//==================================================================================================

#endif
