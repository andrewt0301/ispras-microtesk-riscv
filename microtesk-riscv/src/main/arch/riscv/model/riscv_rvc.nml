/*
 * Copyright 2018 ISP RAS (http://www.ispras.ru)
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */

#ifndef RISCV_RVC_INCLUDED
#define RISCV_RVC_INCLUDED

#include "riscv_rv32i.nml"

#ifdef RV64I
  #include "riscv_rv64i.nml"
#endif

//==================================================================================================
// C Standard Extension for Compressed Instructions
//==================================================================================================

/*
  Instructions (number: ):
    C.LW +
    C.LD +
    C.LQ -
    C.FLW
    C.FLD

    C.SW +
    C.SD +
    C.SQ -
    C.FSW
    C.FSD

    C.LW
    C.LD
    C.LQ -
    C.FLW
    C.FLD
*/

/*
  Instructions (number: 48):
    C.ADDI4SPN (RES, nzimm=0)
    C.FLD (RV32/64)
    C.LQ (RV128)
    C.LW
    C.FLW (RV32)
    C.LD (RV64/128)
    C.FSD (RV32/64)
    C.SQ (RV128)
    C.SW
    C.FSW (RV32)
    C.SD (RV64/128)
    C.NOP
    C.ADDI (HINT, nzimm=0)
    C.JAL (RV32) -
    C.ADDIW (RV64/128; RES, rd=0)
    C.LI (HINT, rd=0)
    C.ADDI16SP (RES, nzimm=0)
    C.LUI (RES, nzimm=0; HINT, rd=0)
    C.SRLI (RV32 NSE, nzimm[5]=1)
    C.SRLI64 (RV128; RV32/64 HINT)
    C.SRAI (RV32 NSE, nzimm[5]=1)
    C.SRAI64 (RV128; RV32/64 HINT)

    C.ANDI +
    C.SUB +
    C.XOR +
    C.OR +
    C.AND +
    C.SUBW (RV64/128; RV32 RES) +
    C.ADDW (RV64/128; RV32 RES) +
    C.J +
    C.BEQZ +
    C.BNEZ +

    C.SLLI (HINT, rd=0; RV32 NSE, nzimm[5]=1) +
    C.SLLI64 (RV128; RV32/64 HINT; HINT, rd=0) +
    C.FLDSP (RV32/64) +
    C.LQSP (RV128; RES, rd=0) +
    C.LWSP (RES, rd=0) +
    C.FLWSP (RV32) +
    C.LDSP (RV64/128; RES, rd=0) +
    C.JR (RES, rs1=0)
    C.MV (HINT, rd=0)
    C.EBREAK
    C.JALR
    C.ADD (HINT, rd=0)
    C.FSDSP (RV32/64)
    C.SQSP (RV128)
    C.SWSP +
    C.FSWSP (RV32)
    C.SDSP (RV64/128) +
*/

//==================================================================================================
// Instruction Templates
//==================================================================================================

/*
CR-type:
op <name>(rd: X/rs1: X, rs2: X)
  syntax = format("<name> %s, %s", rd.syntax/rs1.syntax, rs2.syntax)
  image  = format("<func4>%s%s<opcode>", rs1.i<2..0>/rd.i<2..0>, rs2.i<2..0>)
  action = {
    // TODO
  }

CS-type:
op <name>(rs1: X, rs2: X)
  syntax = format("<name> %s, %s", rs1.syntax, rs2.syntax)
  image  = format("<func6>%3s<func>%3s<opcode>", rs1.i<2..0>, rs2.i<2..0>)
  action = {
    // TODO
  }

CB-type:
op <name>(rs1: X, imm: card(6))
  syntax = format("<name> %s, %s", rs1.syntax, imm)
  image  = format("<func3>%1s<func2>%3s%5s<opcode>", imm<5>, rs1.i<2..0>, imm<4..0>)
  action = {
    // TODO
  }

CI-type:
op <name>(rs1: X, imm: card(6))
  syntax = format("<name> %s, %s", rs1.syntax, imm)
  image  = format("<func3>%1s%3s%5s<opcode>", imm<5>, rs1.i<2..0>, imm<4..0>)
  action = {
    // TODO
  }

CJ-type:
op <name>(target: card(11))
  syntax = format("<name> %s", target)
  image  = format("<func3>%11s<opcode>", target)
  action = {
    // TODO
  }
*/
//==================================================================================================
// Instructions
//==================================================================================================

/*
  C.LWSP
  Format: c_lwsp rd, offset

  C.LWSP loads a 32-bit value from memory into register rd. It computes an effective
  address by adding the zero-extended offset, scaled by 4, to the stack pointer, x2.
  It expands to lw rd, offset[7:2](x2).
*/
op c_lwsp(rd: X, offset: card(6))
  init   = {}
  syntax = format("c.lwsp %s, %d(%s)", rd.syntax, offset, X(2).syntax)
  image  = format("010%s%s%s%s10", offset<3>, rd.image, offset<2..0>, offset<5..4>)
  action = {
    lw(rd, X(2), zero_extend(card(12), offset) << 2).action;
  }

/*
  C.LDSP
  Format: c_ldsp rd, offset

  C.LDSP is an RV64C/RV128C-only instruction that loads a 64-bit value from memory
  into register rd. It computes its effective address by adding the zero-extended offset,
  scaled by 8, to the stack pointer, x2.
  It expands to ld rd, offset[8:3](x2).
*/
@rev(RV64C)
op c_ldsp(rd: X, offset: card(6))
  init   = { assert(rd.i<2..0> == 0b000, "c.ldsp: rd == 0");
    // TODO: rd =/=0
  }
  syntax = format("c.ldsp %s, %d(%s)", rd.syntax, offset, X(2).syntax)
  image  = format("011%s%s%s%s10", offset<2>, rd.image, offset<1..0>, offset<5..3>)
  action = {
    ld(rd, X(2), zero_extend(card(12), offset) << 3).action;
  }

/*
  C.SWSP
  Format: c_swsp rs2, offset

  C.SWSP stores a 32-bit value in register rs2 to memory. It computes an effective address by
  adding the zero-extended offset, scaled by 4, to the stack pointer, x2.
  It expands to sw rs2, offset[7:2](x2).
*/
op c_swsp(rs2: X, offset: card(6))
  init   = {}
  syntax = format("c.swsp %s, %d(%s)", rs2.syntax, offset, X(2).syntax)
  image  = format("110%s%s%s10", offset<3..0>, offset<5..4> , rs2.image)
  action = {
    sw(rs2, X(2), zero_extend(card(12), offset) << 2).action;
  }

/*
  C.SDSP
  Format: c_sdsp rs2, offset

  C.SDSP is an RV64C/RV128C-only instruction that stores a 64-bit value in register rs2 to memory.
  It computes an effective address by adding the zero-extended offset, scaled by 8,
  to the stack pointer, x2.
  It expands to sd rs2, offset[8:3](x2).
*/
op c_sdsp(rs2: X, offset: card(6))
  init   = {}
  syntax = format("c.sdsp %s, %d(%s)", rs2.syntax, offset, X(2).syntax)
  image  = format("111%s%s%s10", offset<2..0>, offset<5..3> , rs2.image)
  action = {
    sw(rs2, X(2), zero_extend(card(12), offset) << 3).action;
  }

/*
  C.LW
  Format: c_lw, rs1, offset

  C.LW loads a 32-bit value from memory into register rd'. It computes an effective address
  by adding the zero-extended offset, scaled by 4, to the base address in register rs1'.
  It expands to lw rd', offset[6:2](rs1').
*/
op c_lw(rd: X, rs1: X, offset: card(5))
  init   = { assert(rd.i<4..3> == 0b01, "Only registers x8-x15 are allowed!");}
  syntax = format("c.lw %s, %d(%s)", rd.syntax, offset, rs1.syntax)
  image  = format("010%s%s%s%s%s00", offset<3..1>, rd.i<2..0>, offset<0>, offset<4>, rs1.i<2..0>)
  action = {
    lw(rd, rs1, zero_extend(card(12), offset) << 2).action;
  }

/*
  C.LD
  Format: c_ld, rs1, offset

  C.LD is an RV64C/RV128C-only instruction that loads a 64-bit value from memory into register rd'.
  It computes an effective address by adding the zero-extended offset, scaled by 8,
  to the base address in register rs1'.
  It expands to ld rd', offset[7:3](rs1').
*/
@rev(RV64C)
op c_ld(rd: X, rs1: X, offset: card(5))
  init   = { assert(rd.i<4..3> == 0b01, "16-bit opcode: only registers x8-x15 are allowed!");}
  syntax = format("c.ld %s, %d(%s)", rd.syntax, offset, rs1.syntax)
  image  = format("011%s%s%s%s00", offset<2..0>, rd.i<2..0>, offset<4..3>, rs1.i<2..0>)
  action = {
    ld(rd, rs1, zero_extend(card(12), offset) << 3).action;
  }

//==================================================================================================

/*
C.ANDI is a CB-format instruction that computes the bitwise AND of of the value in register rd0
and the sign-extended 6-bit immediate, then writes the result to rd0. C.ANDI expands to andi
rd0, rd0, imm[5:0].
*/
op c_andi(rd: X, imm: card(6))
  init   = { assert(rd.i<4..3> == 0b01, "16-bit opcode: only registers x8-x15 are allowed!");}
  syntax = format("c.andi %s, %s", rd.syntax, imm)
  image  = format("100%1s10%3s%5s01", imm<5>, rd.i<2..0>, imm<4..0>)
  action = {
    andi(rd, rd, sign_extend(card(12), imm)).action;
  }

/*
C.ADD adds the values in registers rd and rs2 and writes the result to register rd. C.ADD expands
into add rd, rd, rs2.
*/
op c_add(rd: X, rs2: X)
  init   = { assert(rd.i<4..3> == 0b01, "16-bit opcode: only registers x8-x15 are allowed!");
             assert(rs2.i<4..3> == 0b01, "16-bit opcode: only registers x8-x15 are allowed!");}
  syntax = format("c.add %s, %s", rd.syntax, rs2.syntax)
  image  = format("100011%3s11%3s01", rd.i<2..0>, rs2.i<2..0>)
  action = {
    and(rd, rd, rs2).action;
  }

/*
C.OR computes the bitwise OR of the values in registers rd0 and rs20, then writes the result to
register rd0. C.OR expands into or rd0, rd0, rs20.
*/
op c_or(rd: X, rs2: X)
  init   = { assert(rd.i<4..3> == 0b01, "16-bit opcode: only registers x8-x15 are allowed!");
             assert(rs2.i<4..3> == 0b01, "16-bit opcode: only registers x8-x15 are allowed!");}
  syntax = format("c.or %s, %s", rd.syntax, rs2.syntax)
  image  = format("100011%3s10%3s01", rd.i<2..0>, rs2.i<2..0>)
  action = {
    or(rd, rd, rs2).action;
  }

/*
C.XOR computes the bitwise XOR of the values in registers rd0 and rs20, then writes the result to
register rd0. C.XOR expands into xor rd0, rd0, rs20.
*/
op c_xor(rd: X, rs2: X)
  init   = { assert(rd.i<4..3> == 0b01, "16-bit opcode: only registers x8-x15 are allowed!");
             assert(rs2.i<4..3> == 0b01, "16-bit opcode: only registers x8-x15 are allowed!");}
  syntax = format("c.xor %s, %s", rd.syntax, rs2.syntax)
  image  = format("100011%3s01%3s01", rd.i<2..0>, rs2.i<2..0>)
  action = {
    xor(rd, rd, rs2).action;
  }

/*
C.SUB subtracts the value in register rs20 from the value in register rd0, then writes the result to
register rd0. C.SUB expands into sub rd0, rd0, rs20.
*/
op c_sub(rd: X, rs2: X)
  init   = { assert(rd.i<4..3> == 0b01, "16-bit opcode: only registers x8-x15 are allowed!");
             assert(rs2.i<4..3> == 0b01, "16-bit opcode: only registers x8-x15 are allowed!");}
  syntax = format("c.sub %s, %s", rd.syntax, rs2.syntax)
  image  = format("100011%3s00%3s01", rd.i<2..0>, rs2.i<2..0>)
  action = {
    sub(rd, rd, rs2).action;
  }

/*
C.ADDW is an RV64C/RV128C-only instruction that adds the values in registers rd0 and rs20,
then sign-extends the lower 32 bits of the sum before writing the result to register rd0. C.ADDW
expands into addw rd0, rd0, rs20.
*/
@rev(RV64C)
op c_addw(rd: X, rs2: X)
  init   = { assert(rd.i<4..3> == 0b01, "16-bit opcode: only registers x8-x15 are allowed!");
             assert(rs2.i<4..3> == 0b01, "16-bit opcode: only registers x8-x15 are allowed!");}
  syntax = format("c.addw %s, %s", rd.syntax, rs2.syntax)
  image  = format("100111%3s01%3s01", rd.i<2..0>, rs2.i<2..0>)
  action = {
    addw(rd, rd, rs2).action;
  }

/*
C.SUBW is an RV64C/RV128C-only instruction that subtracts the value in register rs20 from the
value in register rd0, then sign-extends the lower 32 bits of the difference before writing the result
to register rd0. C.SUBW expands into subw rd0, rd0, rs20.
*/
@rev(RV64C)
op c_subw(rd: X, rs2: X)
  init   = { assert(rd.i<4..3> == 0b01, "16-bit opcode: only registers x8-x15 are allowed!");
             assert(rs2.i<4..3> == 0b01, "16-bit opcode: only registers x8-x15 are allowed!");}
  syntax = format("c.subw %s, %s", rd.syntax, rs2.syntax)
  image  = format("100111%3s00%3s01", rd.i<2..0>, rs2.i<2..0>)
  action = {
    addw(rd, rd, rs2).action;
  }

/*
C.J performs an unconditional control transfer. The offset is sign-extended and added to the pc to
form the jump target address. C.J can therefore target a +-2 KiB range. C.J expands to jal x0,
offset[11:1].
*/
var c_jump_imm12[card(12)]

mode C_JUMP_IMM(imm: int(12)) = imm
  init = {
    c_jump_imm12 = imm;
  }
  syntax = format("0x%X", imm)
  image = format("%s", imm)

label mode C_JUMP_LABEL(target: WORD, current: WORD) = target<11..0> - current<11..0>
  init = {
    c_jump_imm12 = target<11..0> - current<11..0>;
  }
  syntax = ""
  image = format("%s", target<11..0> - current<11..0>)

mode C_JUMP_ADDR = C_JUMP_LABEL | C_JUMP_IMM

@rev(RV32C)
op c_j(target: C_JUMP_ADDR)
  init   = {}
  syntax = format("c.j %s", target.syntax)
  image  = format("101%1s%1s%2s%1s%1s%1s%3s%1s01", c_jump_imm12<11>, c_jump_imm12<4>,
                  c_jump_imm12<9..8>, c_jump_imm12<10>, c_jump_imm12<6>, c_jump_imm12<7>,
                  c_jump_imm12<3..1>, c_jump_imm12<5>)
  action = {
    //jal(X(0), sign_extend(card(20), c_jump_imm12)).action;
    // TODO;
  }

/*
C.JAL is an RV32C-only instruction that performs the same operation as C.J, but additionally
writes the address of the instruction following the jump (pc+2) to the link register, x1. C.JAL
expands to jal x1, offset[11:1].
*/
op c_jal(target: C_JUMP_ADDR)
  init   = {}
  syntax = format("c.jal %s", target.syntax)
  image  = format("001%1s%1s%2s%1s%1s%1s%3s%1s01", c_jump_imm12<11>, c_jump_imm12<4>,
                  c_jump_imm12<9..8>, c_jump_imm12<10>, c_jump_imm12<6>, c_jump_imm12<7>,
                  c_jump_imm12<3..1>, c_jump_imm12<5>)
  action = {
    //jal(X(1), sign_extend(card(20), c_jump_imm12)).action;
    // TODO;
  }

/*
C.BEQZ performs conditional control transfers. The offset is sign-extended and added to the pc to
form the branch target address. It can therefore target a +-256B range. C.BEQZ takes the branch
if the value in register rs10 is zero. It expands to beq rs10, x0, offset[8:1].
*/
op c_beqz(rs1: X, offset: card(9))
  init   = { assert(rs1.i<4..3> == 0b01, "16-bit opcode: only registers x8-x15 are allowed!");}
  syntax = format("c.beqz %s, %s", rs1.syntax, offset)
  image  = format("110%1s%2s%3s%2s%2s%1s01", offset<8>, offset<4..3>, rs1.i<2..0>, offset<7..6>, offset<2..1>, offset<5>)
  action = {
    //beq(rs1, X(0), sign_extend(card(20), offset)).action;
    // TODO:
  }

/*
C.BNEZ is defined analogously, but it takes the branch if rs10 contains a nonzero value. It expands
to bne rs10, x0, offset[8:1].
*/
op c_bnez(rs1: X, offset: card(9))
  init   = { assert(rs1.i<4..3> == 0b01, "16-bit opcode: only registers x8-x15 are allowed!");}
  syntax = format("c.bnez %s, %s", rs1.syntax, offset)
  image  = format("111%1s%2s%3s%2s%2s%1s01", offset<8>, offset<4..3>, rs1.i<2..0>, offset<7..6>, offset<2..1>, offset<5>)
  action = {
    //bne(rs1, X(0), sign_extend(card(20), offset)).action;
    // TODO:
  }

/*
C.SLLI is a CI-format instruction that performs a logical left shift of the value in register rd then
writes the result to rd. The shift amount is encoded in the shamt field, where shamt[5] must be
zero for RV32C. For RV32C and RV64C, the shift amount must be non-zero. For RV128C, a shift
amount of zero is used to encode a shift of 64. C.SLLI expands into slli rd, rd, shamt[5:0],
except for RV128C with shamt=0, which expands to slli rd, rd, 64.
*/
op c_slli(rd: X, shamt: card(6))
  init   = { assert(rd.i<4..3> == 0b01, "16-bit opcode: only registers x8-x15 are allowed!");
             assert(rd.i<2..0> == 0b000, "c.slli: rd == 0");
             #ifndef RV128C
               #ifdef RV32C
                 assert(shamt<5> != 0b0, "c.slli(RV32C): shamt<5> != 0");
                 assert(shamt == 0b0, "c.slli(RV32C): shamt == 0");
               #endif
               #ifdef RV64C
                 assert(shamt == 0b0, "c.slli(RV64C): shamt == 0");
               #endif
             #endif
           }
  syntax = format("c.slli %s, %s", rd.syntax, shamt)
  image  = format("000%1s%3s%5s10", shamt<5>, rd.i<2..0>, shamt<4..0>)
  action = {
    #ifdef RV128C
      if shamt == 0 then
        slli(rd, rd, 64).action;
      else
        slli(rd, rd, shamt).action;
      endif;
    #else
       slli(rd, rd, shamt).action;
    #endif
  }

@rev(RV128C)
op c_slli64(rd: X)
  init = {c_slli(rd, 0).init;}
  syntax = format("c.slli64 %s", rd.syntax)
  image = format("%s", c_slli(rd, 0).image)
  action = {
    c_slli(rd, 0).action;
  }

/*
C.LQSP is an RV128C-only instruction that loads a 128-bit value from memory into register rd. It
computes its effective address by adding the zero-extended offset, scaled by 16, to the stack pointer,
x2. It expands to lq rd, offset[9:4](x2).
*/
@rev(RV128C)
op c_lqsp(rd: X, offset: card(6))
  init   = { assert(rd.i<4..3> == 0b01, "16-bit opcode: only registers x8-x15 are allowed!");
             assert(rd.i<2..0> == 0b000, "c.lqsp: rd == 0"); }
  syntax = format("c.lqsp %s, %s", rd.syntax, offset)
  image  = format("001%1s%3s%1s%4s10", offset<1>, rd.i<2..0>, offset<0>, offset<5..2>)
  action = {
    // lq(rd, zero_extend(card(12), offset) << 4, X(2)).action;
    // TODO: lq
  }

/*
C.FLWSP is an RV32FC-only instruction that loads a single-precision floating-point value from memory
into floating-point register rd. It computes its effective address by adding the zero-extended
offset, scaled by 4, to the stack pointer, x2. It expands to flw rd, offset[7:2](x2).
*/
@rev(RV32FC)
op c_flwsp(rd: FR, offset: card(6))
  init   = { assert(rd.i<4..3> == 0b01, "16-bit opcode: only registers x8-x15 are allowed!");
             assert(rd.i<2..0> == 0b000, "c.lqsp: rd == 0"); }
  syntax = format("c.flwsp %s, %s", rd.syntax, offset)
  image  = format("011%1s%3s%3s%2s10", offset<3>, rd.i<2..0>, offset<2..0>, offset<5..4>)
  action = {
    flw(rd, zero_extend(card(12), offset) << 2, X(2)).action;
  }

/*
C.FLDSP is an RV32DC/RV64DC-only instruction that loads a double-precision floating-point
value from memory into floating-point register rd. It computes its effective address by adding
the zero-extended offset, scaled by 8, to the stack pointer, x2. It expands to fld rd,
offset[8:3](x2).
*/
@rev(RV32DC)
op c_fldsp(rd: FR, offset: card(6))
  init   = { assert(rd.i<4..3> == 0b01, "16-bit opcode: only registers x8-x15 are allowed!");}
  syntax = format("c.fldsp %s, %s", rd.syntax, offset)
  image  = format("001%1s%3s%2s%3s10", offset<2>, rd.i<2..0>, offset<1..0>, offset<5..3>)
  action = {
    flw(rd, zero_extend(card(12), offset) << 3, X(2)).action;
  }

//==================================================================================================
// Instruction Groups
//==================================================================================================

op rvc =              c_lwsp
       | @rev(RV64C)  c_ldsp
       |              c_swsp
       | @rev(RV64C)  c_sdsp
       |              c_lw
       | @rev(RV64C)  c_ld
       |              c_andi
       |              c_add
       |              c_or
       |              c_xor
       |              c_sub
       | @rev(RV64C)  c_addw
       | @rev(RV64C)  c_subw
       |              c_j
       | @rev(RV32C)  c_jal
       |              c_beqz
       |              c_bnez
       |              c_slli
       | @rev(RV128C) c_slli64
       | @rev(RV128C) c_lqsp
       | @rev(RV32FC) c_flwsp
       | @rev(RV32DC) c_fldsp

//==================================================================================================
// The End
//==================================================================================================

#endif
