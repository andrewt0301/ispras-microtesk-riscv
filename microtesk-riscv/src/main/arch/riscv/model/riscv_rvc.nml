/*
 * Copyright 2018 ISP RAS (http://www.ispras.ru)
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */

#ifndef RISCV_RVC_INCLUDED
#define RISCV_RVC_INCLUDED

#include "riscv_rv32i.nml"

#ifdef RV64I
  #include "riscv_rv64i.nml"
#endif

//==================================================================================================
// C Standard Extension for Compressed Instructions
//==================================================================================================

/*
  Instructions (number: ):
    C.LW +
    C.LD +
    C.LQ -
    C.FLW
    C.FLD

    C.SW +
    C.SD +
    C.SQ -
    C.FSW
    C.FSD

    C.LW
    C.LD
    C.LQ -
    C.FLW
    C.FLD
*/

/*
  Instructions (number: 48):
    C.ADDI4SPN (RES, nzimm=0)
    C.FLD (RV32/64)
    C.LQ (RV128)
    C.LW
    C.FLW (RV32)
    C.LD (RV64/128)
    C.FSD (RV32/64)
    C.SQ (RV128)
    C.SW
    C.FSW (RV32)
    C.SD (RV64/128)
    C.NOP
    C.ADDI (HINT, nzimm=0)
    C.JAL (RV32)
    C.ADDIW (RV64/128; RES, rd=0)
    C.LI (HINT, rd=0)
    C.ADDI16SP (RES, nzimm=0)
    C.LUI (RES, nzimm=0; HINT, rd=0)
    C.SRLI (RV32 NSE, nzimm[5]=1)
    C.SRLI64 (RV128; RV32/64 HINT)
    C.SRAI (RV32 NSE, nzimm[5]=1)
    C.SRAI64 (RV128; RV32/64 HINT)

    C.ANDI
    C.SUB
    C.XOR
    C.OR
    C.AND
    C.SUBW (RV64/128; RV32 RES)
    C.ADDW (RV64/128; RV32 RES)
    C.J
    C.BEQZ
    C.BNEZ

    C.SLLI (HINT, rd=0; RV32 NSE, nzimm[5]=1)
    C.SLLI64 (RV128; RV32/64 HINT; HINT, rd=0)
    C.FLDSP (RV32/64)
    C.LQSP (RV128; RES, rd=0)C.LWSP (RES, rd=0)
    C.FLWSP (RV32)
    C.LDSP (RV64/128; RES, rd=0)
    C.JR (RES, rs1=0)
    C.MV (HINT, rd=0)
    C.EBREAK
    C.JALR
    C.ADD (HINT, rd=0)
    C.FSDSP (RV32/64)
    C.SQSP (RV128)
    C.SWSP
    C.FSWSP (RV32)
    C.SDSP (RV64/128)
*/

//==================================================================================================
// Instruction Templates
//==================================================================================================

/*
CR-type:
op <name>(rd: X/rs1: X, rs2: X)
  syntax = format("<name> %s, %s", rd.syntax/rs1.syntax, rs2.syntax)
  image  = format("<func4>%s%s<opcode>", rs1.image/rd.image, rs2.image)
  action = {
    // TODO
  }

CB-type:
op <name>(rs1: X, imm: card(6))
  syntax = format("<name> %s, %s", rs1.syntax, imm)
  image  = format("<func3>%1s<func2>%3s%5s<opcode>", imm<5>, rs1.image, imm<4..0>)
  action = {
    // TODO
  }
*/
//==================================================================================================
// Instructions
//==================================================================================================

/*
  C.LWSP
  Format: c_lwsp rd, offset

  C.LWSP loads a 32-bit value from memory into register rd. It computes an effective
  address by adding the zero-extended offset, scaled by 4, to the stack pointer, x2.
  It expands to lw rd, offset[7:2](x2).
*/
op c_lwsp(rd: X, offset: card(6))
  syntax = format("c.lwsp %s, %d(%s)", rd.syntax, offset, X(2).syntax)
  image  = format("010%s%s%s%s10", offset<3>, rd.image, offset<2..0>, offset<5..4>)
  action = {
    lw(rd, X(2), zero_extend(card(12), offset) << 2).action;
  }

/*
  C.LDSP
  Format: c_ldsp rd, offset

  C.LDSP is an RV64C/RV128C-only instruction that loads a 64-bit value from memory
  into register rd. It computes its effective address by adding the zero-extended offset,
  scaled by 8, to the stack pointer, x2.
  It expands to ld rd, offset[8:3](x2).
*/
@rev(RV64C)
op c_ldsp(rd: X, offset: card(6))
  syntax = format("c.ldsp %s, %d(%s)", rd.syntax, offset, X(2).syntax)
  image  = format("011%s%s%s%s10", offset<2>, rd.image, offset<1..0>, offset<5..3>)
  action = {
    ld(rd, X(2), zero_extend(card(12), offset) << 3).action;
  }

/*
  C.SWSP
  Format: c_swsp rs2, offset

  C.SWSP stores a 32-bit value in register rs2 to memory. It computes an effective address by
  adding the zero-extended offset, scaled by 4, to the stack pointer, x2.
  It expands to sw rs2, offset[7:2](x2).
*/
op c_swsp(rs2: X, offset: card(6))
  syntax = format("c.swsp %s, %d(%s)", rs2.syntax, offset, X(2).syntax)
  image  = format("110%s%s%s10", offset<3..0>, offset<5..4> , rs2.image)
  action = {
    sw(rs2, X(2), zero_extend(card(12), offset) << 2).action;
  }

/*
  C.SDSP
  Format: c_sdsp rs2, offset

  C.SDSP is an RV64C/RV128C-only instruction that stores a 64-bit value in register rs2 to memory.
  It computes an effective address by adding the zero-extended offset, scaled by 8,
  to the stack pointer, x2.
  It expands to sd rs2, offset[8:3](x2).
*/
op c_sdsp(rs2: X, offset: card(6))
  syntax = format("c.sdsp %s, %d(%s)", rs2.syntax, offset, X(2).syntax)
  image  = format("111%s%s%s10", offset<2..0>, offset<5..3> , rs2.image)
  action = {
    sw(rs2, X(2), zero_extend(card(12), offset) << 3).action;
  }

/*
  C.LW
  Format: c_lw, rs1, offset

  C.LW loads a 32-bit value from memory into register rd'. It computes an effective address
  by adding the zero-extended offset, scaled by 4, to the base address in register rs1'.
  It expands to lw rd', offset[6:2](rs1').
*/
// FIXME: Registers X' (3-bit index) are required.
op c_lw(rd: X, rs1: X, offset: card(5))
  syntax = format("c.lw %s, %d(%s)", rd.syntax, offset, rs1.syntax)
  image  = format("010%s%s%s%s%s00", offset<3..1>, rd.i<2..0>, offset<0>, offset<4>, rs1.i<2..0>)
  action = {
    lw(rd, rs1, zero_extend(card(12), offset) << 2).action;
  }

/*
  C.LD
  Format: c_ld, rs1, offset

  C.LD is an RV64C/RV128C-only instruction that loads a 64-bit value from memory into register rd'.
  It computes an effective address by adding the zero-extended offset, scaled by 8,
  to the base address in register rs1'.
  It expands to ld rd', offset[7:3](rs1').
*/
// FIXME: Registers X' (3-bit index) are required.
@rev(RV64C)
op c_ld(rd: X, rs1: X, offset: card(5))
  syntax = format("c.ld %s, %d(%s)", rd.syntax, offset, rs1.syntax)
  image  = format("011%s%s%s%s00", offset<2..0>, rd.i<2..0>, offset<4..3>, rs1.i<2..0>)
  action = {
    ld(rd, rs1, zero_extend(card(12), offset) << 3).action;
  }


//==================================================================================================

/*
C.ANDI is a CB-format instruction that computes the bitwise AND of of the value in register rd0
and the sign-extended 6-bit immediate, then writes the result to rd0. C.ANDI expands to andi
rd0, rd0, imm[5:0].
*/
op c_andi(rd: X, imm: card(6))
  syntax = format("c.andi %s, %s", rd.syntax, imm)
  image  = format("100%1s10%3s%5s01", imm<5>, rd.i<2..0>, imm<4..0>)
  action = {
    andi(rd, rd, sign_extend(card(12), imm)).action;
  }

//==================================================================================================
// Instruction Groups
//==================================================================================================

op rvc =             c_lwsp
       | @rev(RV64C) c_ldsp
       |             c_swsp
       | @rev(RV64C) c_sdsp
       |             c_lw
       | @rev(RV64C) c_ld

//==================================================================================================
// The End
//==================================================================================================

#endif
